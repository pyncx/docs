{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NCX Channel Modeling This online document helps the absolute beginners to persue the future direction in coding and modeling Markov Models for ion channels. The lesson starts with how to write code in Python along with fundamental ideas in data structure, function and class, Numpy. Following are the major techniques implemented Analytical Solutions : Manual implementation of condition of equilibrium and detailed balance. Numerical Methods : Simultaneous Ordinary Differential Equations : Solving differential equation by implementation of numerical methods. Algebraic Method : Translation of differential equations into an algebraic problem as linear equation of matrices and vector. Monte Carlo Simulation : Random generation of states based on wighted probability distribution and calculation fraction of states at equilibrium.","title":"Home"},{"location":"#ncx-channel-modeling","text":"This online document helps the absolute beginners to persue the future direction in coding and modeling Markov Models for ion channels. The lesson starts with how to write code in Python along with fundamental ideas in data structure, function and class, Numpy. Following are the major techniques implemented Analytical Solutions : Manual implementation of condition of equilibrium and detailed balance. Numerical Methods : Simultaneous Ordinary Differential Equations : Solving differential equation by implementation of numerical methods. Algebraic Method : Translation of differential equations into an algebraic problem as linear equation of matrices and vector. Monte Carlo Simulation : Random generation of states based on wighted probability distribution and calculation fraction of states at equilibrium.","title":"NCX Channel Modeling"},{"location":"WhyCodes/","text":"Why Codes? Codes are apparently the language for Human-Machine interface. Coding is the most fundamental skill required for growing with modern days technology. Sicen our computers are built up based on logic and algorithm, our coding languages are also higher lavel of logical steps made undersatndable for human. By typing a line of code, we are speaking the laguage of the machine. Fundamentally, each programming language has it's inner working principle with underlying datastructure and functions. Computer while running a piece of code maintains the data in the memory ( temporary at RAM or permanent at Hard Disk). Whil code is live in the machine, it has time and space complexicities with the underlying datastructure and algotihm excuting the task.","title":"Why Codes?"},{"location":"WhyCodes/#why-codes","text":"Codes are apparently the language for Human-Machine interface. Coding is the most fundamental skill required for growing with modern days technology. Sicen our computers are built up based on logic and algorithm, our coding languages are also higher lavel of logical steps made undersatndable for human. By typing a line of code, we are speaking the laguage of the machine. Fundamentally, each programming language has it's inner working principle with underlying datastructure and functions. Computer while running a piece of code maintains the data in the memory ( temporary at RAM or permanent at Hard Disk). Whil code is live in the machine, it has time and space complexicities with the underlying datastructure and algotihm excuting the task.","title":"Why Codes?"},{"location":"prog/","text":"Introduction to Python programming Course Track: Fundamental DataStructure Loops and Condition Project Fern Function and Class Project N-charges Project Random Walk Project Diffusion","title":"Prog"},{"location":"prog/#introduction-to-python-programming","text":"Course Track: Fundamental DataStructure Loops and Condition Project Fern Function and Class Project N-charges Project Random Walk Project Diffusion","title":"Introduction to Python programming"},{"location":"GettingStarted/anaconda/","text":"Installing Python To install Anaconda Python follow the instruction at Anaconda Distribution Website . Based on the operating system select the proper version of the Anaconda package and install it in your PC. After you successfully install the proper version, you will get anaconda application in you PC which will look like the figure below: Best way to start with is the \"Jupyter notebook\". Lunch the jupyter notebook to start with Python. Note- Linux: For Linux user, it could be little bit tricky. SOme time it becomes hard to locate anaconda path to the environment so you need to point the python you want to use. Please, run the command below to point the python: bash export PATH=/home/ubuntu/anaconda3/bin:$PATH There is 'base' or 'anaconda3' environment by defult. You can find the list of available environmet by typing following command on the terminal bash conda env list To start the 'base' environment type bash source activate base To install new package for example 'jupyter notebook' type bash pip install jupyter notebook After sucessfully installing Jupyter notebook, tye following to start it bash Jupyter notebook Note - Cloud For running Jupyter notebook in AWS cloud, it is important to open the \"8888\" to \"8889\" with TCP rule with IP \"0.0.0.0\" and allow to be opend from anywhere. Once port is open, type following to bash jupyter notebook --ip=0.0.0.0 --no-browser","title":"Guide to starting Python"},{"location":"GettingStarted/anaconda/#installing-python","text":"To install Anaconda Python follow the instruction at Anaconda Distribution Website . Based on the operating system select the proper version of the Anaconda package and install it in your PC. After you successfully install the proper version, you will get anaconda application in you PC which will look like the figure below: Best way to start with is the \"Jupyter notebook\". Lunch the jupyter notebook to start with Python.","title":"Installing Python"},{"location":"GettingStarted/anaconda/#note-linux","text":"For Linux user, it could be little bit tricky. SOme time it becomes hard to locate anaconda path to the environment so you need to point the python you want to use. Please, run the command below to point the python: bash export PATH=/home/ubuntu/anaconda3/bin:$PATH There is 'base' or 'anaconda3' environment by defult. You can find the list of available environmet by typing following command on the terminal bash conda env list To start the 'base' environment type bash source activate base To install new package for example 'jupyter notebook' type bash pip install jupyter notebook After sucessfully installing Jupyter notebook, tye following to start it bash Jupyter notebook","title":"Note- Linux:"},{"location":"GettingStarted/anaconda/#note-cloud","text":"For running Jupyter notebook in AWS cloud, it is important to open the \"8888\" to \"8889\" with TCP rule with IP \"0.0.0.0\" and allow to be opend from anywhere. Once port is open, type following to bash jupyter notebook --ip=0.0.0.0 --no-browser","title":"Note - Cloud"},{"location":"GettingStarted/env/","text":"Python Environment Basics To avoid errors later, it's best to update all the packages in the default environment. Open the Anaconda Prompt application. In the prompt, run the following commands: conda upgrade conda conda upgrade --all If you are seeing the following \"conda command not found\" and are using ZShell, you have to do the following: export PATH = \"/Users/username/anaconda/bin: $PATH \" or update above command line to your .zsh_config file. Once you have Anaconda installed, managing packages is fairly straightforward. To install a package, type conda install package_name in your terminal. For example, to install numpy, type conda install numpy. You can install multiple packages at the same time. Something like conda install numpy scipy pandas will install all those packages simultaneously. It's also possible to specify which version of a package you want by adding the version number such as conda install numpy = 1 .10. Conda also automatically installs dependencies for you. For example scipy depends on numpy, it uses and requires numpy. If you install just scipy (conda install scipy), Conda will also install numpy if it isn't already installed. Most of the commands are pretty intuitive. To uninstall, use conda remove package_name To update a package conda update package_name If you want to update all packages in an environment, which is often useful, use conda update --all And finally, to list installed packages, it's conda list If you don't know the exact name of the package you're looking for, you can try searching with conda search search_term For example, I know I want to install Beautiful Soup, but I'm not sure of the exact package name. So, I try conda search beautifulsoup Environments Conda can be used to create environments to isolate your projects. To create an environment, use conda create -n env_name list of packages in your terminal Here -n env_name sets the name of your environment (-n for name) and list of packages is the list of packages you want installed in the environment. For example, to create an environment named my_env and install numpy in it, type conda create -n my_env numpy When creating an environment, you can specify which version of Python to install in the environment. This is useful when you're working with code in both Python 2.x and Python 3.x. To create an environment with a specific Python version, do something like conda create -n py3 python = 3 or conda create -n py2 python = 2 I actually have both of these environments on my personal computer. I use them as general environments not tied to any specific project, but rather for general work with each Python version easily accessible. These commands will install the most recent version of Python 3 and 2, respectively. To install a specific version, use conda create -n py python = 3 .3 for Python 3.3. Once you have an environment created, use source activate my_env to enter it on OSX/Linux. On Windows, use activate my_env When you're in the environment, you'll see the environment name in the terminal prompt. Something like (my_env) ~ $. The environment has only a few packages installed by default, plus the ones you installed when creating it. You can check this out with conda list. Installing packages in the environment is the same as before: conda install package_name Only this time, the specific packages you install will only be available when you're in the environment. To leave the environment, type source deactivate ( on OSX/Linux ) On Windows, use deactivate Saving and loading environments A really useful feature is sharing environments so others can install all the packages used in your code, with the correct versions. You can save the packages to a YAML file with conda env export > environment.yaml The first part conda env export writes out all the packages in the environment, including the Python version. Above you can see the name of the environment and all the dependencies (along with versions) are listed. The second part of the export command, > environment.yaml writes the exported text to a YAML file environment.yaml . This file can now be shared and others will be able to create the same environment you used for the project. To create an environment from an environment file use conda env create -f environment.yaml This will create a new environment with the same name listed in environment.yaml . Listing environments If you forget what your environments are named (happens to me sometimes), use conda env list to list out all the environments you've created. You should see a list of environments, there will be an asterisk next to the environment you're currently in. The default environment, the environment used when you aren't in one, is called root . Removing environments If there are environments you don't use anymore, conda env remove -n env_name will remove the specified environment (here, named env_name ). Using environments One thing that\u2019s helped me tremendously is having separate environments for Python 2 and Python 3. I used conda create -n py2 python = 2 and conda create -n py3 python = 3 to create two separate environments, py2 and py3 . Now I have a general use environment for each Python version. In each of those environments, I've installed most of the standard data science packages (numpy, scipy, pandas, etc.) I\u2019ve also found it useful to create environments for each project I\u2019m working on. It works great for non-data related projects too like web apps with Flask. For example, I have an environment for my personal blog using Pelican . Sharing environments When sharing your code on GitHub, it's good practice to make an environment file and include it in the repository. This will make it easier for people to install all the dependencies for your code. I also usually include a pip requirements.txt file using pip freeze ( learn more here ) for people not using conda. More to learn To learn more about conda and how it fits in the Python ecosystem, check out this article by Jake Vanderplas: Conda myths and misconceptions. And here's the conda documentation you can reference later.","title":"Setting up Python Environment"},{"location":"GettingStarted/env/#python-environment","text":"","title":"Python Environment"},{"location":"GettingStarted/env/#basics","text":"To avoid errors later, it's best to update all the packages in the default environment. Open the Anaconda Prompt application. In the prompt, run the following commands: conda upgrade conda conda upgrade --all If you are seeing the following \"conda command not found\" and are using ZShell, you have to do the following: export PATH = \"/Users/username/anaconda/bin: $PATH \" or update above command line to your .zsh_config file. Once you have Anaconda installed, managing packages is fairly straightforward. To install a package, type conda install package_name in your terminal. For example, to install numpy, type conda install numpy. You can install multiple packages at the same time. Something like conda install numpy scipy pandas will install all those packages simultaneously. It's also possible to specify which version of a package you want by adding the version number such as conda install numpy = 1 .10. Conda also automatically installs dependencies for you. For example scipy depends on numpy, it uses and requires numpy. If you install just scipy (conda install scipy), Conda will also install numpy if it isn't already installed. Most of the commands are pretty intuitive. To uninstall, use conda remove package_name To update a package conda update package_name If you want to update all packages in an environment, which is often useful, use conda update --all And finally, to list installed packages, it's conda list If you don't know the exact name of the package you're looking for, you can try searching with conda search search_term For example, I know I want to install Beautiful Soup, but I'm not sure of the exact package name. So, I try conda search beautifulsoup","title":"Basics"},{"location":"GettingStarted/env/#environments","text":"Conda can be used to create environments to isolate your projects. To create an environment, use conda create -n env_name list of packages in your terminal Here -n env_name sets the name of your environment (-n for name) and list of packages is the list of packages you want installed in the environment. For example, to create an environment named my_env and install numpy in it, type conda create -n my_env numpy When creating an environment, you can specify which version of Python to install in the environment. This is useful when you're working with code in both Python 2.x and Python 3.x. To create an environment with a specific Python version, do something like conda create -n py3 python = 3 or conda create -n py2 python = 2 I actually have both of these environments on my personal computer. I use them as general environments not tied to any specific project, but rather for general work with each Python version easily accessible. These commands will install the most recent version of Python 3 and 2, respectively. To install a specific version, use conda create -n py python = 3 .3 for Python 3.3. Once you have an environment created, use source activate my_env to enter it on OSX/Linux. On Windows, use activate my_env When you're in the environment, you'll see the environment name in the terminal prompt. Something like (my_env) ~ $. The environment has only a few packages installed by default, plus the ones you installed when creating it. You can check this out with conda list. Installing packages in the environment is the same as before: conda install package_name Only this time, the specific packages you install will only be available when you're in the environment. To leave the environment, type source deactivate ( on OSX/Linux ) On Windows, use deactivate","title":"Environments"},{"location":"GettingStarted/env/#saving-and-loading-environments","text":"A really useful feature is sharing environments so others can install all the packages used in your code, with the correct versions. You can save the packages to a YAML file with conda env export > environment.yaml The first part conda env export writes out all the packages in the environment, including the Python version. Above you can see the name of the environment and all the dependencies (along with versions) are listed. The second part of the export command, > environment.yaml writes the exported text to a YAML file environment.yaml . This file can now be shared and others will be able to create the same environment you used for the project. To create an environment from an environment file use conda env create -f environment.yaml This will create a new environment with the same name listed in environment.yaml .","title":"Saving and loading environments"},{"location":"GettingStarted/env/#listing-environments","text":"If you forget what your environments are named (happens to me sometimes), use conda env list to list out all the environments you've created. You should see a list of environments, there will be an asterisk next to the environment you're currently in. The default environment, the environment used when you aren't in one, is called root .","title":"Listing environments"},{"location":"GettingStarted/env/#removing-environments","text":"If there are environments you don't use anymore, conda env remove -n env_name will remove the specified environment (here, named env_name ).","title":"Removing environments"},{"location":"GettingStarted/env/#using-environments","text":"One thing that\u2019s helped me tremendously is having separate environments for Python 2 and Python 3. I used conda create -n py2 python = 2 and conda create -n py3 python = 3 to create two separate environments, py2 and py3 . Now I have a general use environment for each Python version. In each of those environments, I've installed most of the standard data science packages (numpy, scipy, pandas, etc.) I\u2019ve also found it useful to create environments for each project I\u2019m working on. It works great for non-data related projects too like web apps with Flask. For example, I have an environment for my personal blog using Pelican .","title":"Using environments"},{"location":"GettingStarted/env/#sharing-environments","text":"When sharing your code on GitHub, it's good practice to make an environment file and include it in the repository. This will make it easier for people to install all the dependencies for your code. I also usually include a pip requirements.txt file using pip freeze ( learn more here ) for people not using conda.","title":"Sharing environments"},{"location":"GettingStarted/env/#more-to-learn","text":"To learn more about conda and how it fits in the Python ecosystem, check out this article by Jake Vanderplas: Conda myths and misconceptions. And here's the conda documentation you can reference later.","title":"More to learn"},{"location":"GettingStarted/git/","text":"How to git Reference : How to Git Create a new repository on GitHub. To avoid errors, do not initialize the new repository with README, license, or gitignore files. You can add these files after your project has been pushed to GitHub. Open Terminal. Change the current working directory to your local project. Initialize the local directory as a Git repository. git init Add the files in your new local repository. This stages them for the first commit. git add . Adds the files in the local repository and stages them for commit. To unstage a file, use 'git reset HEAD YOUR-FILE'. Commit the files that you've staged in your local repository. git commit -m \"First commit\" Commits the tracked changes and prepares them to be pushed to a remote repository. To remove this commit and modify the file, use 'git reset --soft HEAD~1' and commit and add the file again. Copy remote repository URL fieldAt the top of your GitHub repository's Quick Setup page, click to copy the remote repository URL. In Terminal, add the URL for the remote repository where your local repository will be pushed. git remote add origin remote repository URL Sets the new remote git remote -v Verifies the new remote URL Push the changes in your local repository to GitHub. git push origin master Pushes the changes in your local repository up to the remote repository you specified as the origin","title":"How to Git"},{"location":"GettingStarted/git/#how-to-git","text":"Reference : How to Git Create a new repository on GitHub. To avoid errors, do not initialize the new repository with README, license, or gitignore files. You can add these files after your project has been pushed to GitHub. Open Terminal. Change the current working directory to your local project. Initialize the local directory as a Git repository. git init Add the files in your new local repository. This stages them for the first commit. git add . Adds the files in the local repository and stages them for commit. To unstage a file, use 'git reset HEAD YOUR-FILE'. Commit the files that you've staged in your local repository. git commit -m \"First commit\" Commits the tracked changes and prepares them to be pushed to a remote repository. To remove this commit and modify the file, use 'git reset --soft HEAD~1' and commit and add the file again. Copy remote repository URL fieldAt the top of your GitHub repository's Quick Setup page, click to copy the remote repository URL. In Terminal, add the URL for the remote repository where your local repository will be pushed. git remote add origin remote repository URL Sets the new remote git remote -v Verifies the new remote URL Push the changes in your local repository to GitHub. git push origin master Pushes the changes in your local repository up to the remote repository you specified as the origin","title":"How to git"},{"location":"GettingStarted/jupyter/","text":"Installing Jupyter Notebook By far the easiest way to install Jupyter is with Anaconda. Jupyter notebooks automatically come with the distribution. You'll be able to use notebooks from the default environment. To install Jupyter notebooks in a conda environment, use conda install jupyter notebook Jupyter notebooks are also available through pip with pip install jupyter notebook Markdown Cheatsheet : https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet Convert a notebook to an HTML file, in your terminal use jupyter nbconvert --to html notebook.ipynb Convert: https://nbconvert.readthedocs.io/en/latest/usage.html To create the slideshow from the notebook file, you'll need to use nbconvert: jupyter nbconvert notebook.ipynb --to slides This just converts the notebook to the necessary files for the slideshow, but you need to serve it with an HTTP server to actually see the presentation. To convert it and immediately see it, use jupyter nbconvert notebook.ipynb --to slides --post serve This will open up the slideshow in your browser so you can present it. panda presentation: presentation","title":"Installing Jupyter Notebook"},{"location":"GettingStarted/jupyter/#installing-jupyter-notebook","text":"By far the easiest way to install Jupyter is with Anaconda. Jupyter notebooks automatically come with the distribution. You'll be able to use notebooks from the default environment. To install Jupyter notebooks in a conda environment, use conda install jupyter notebook Jupyter notebooks are also available through pip with pip install jupyter notebook Markdown Cheatsheet : https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet Convert a notebook to an HTML file, in your terminal use jupyter nbconvert --to html notebook.ipynb Convert: https://nbconvert.readthedocs.io/en/latest/usage.html To create the slideshow from the notebook file, you'll need to use nbconvert: jupyter nbconvert notebook.ipynb --to slides This just converts the notebook to the necessary files for the slideshow, but you need to serve it with an HTTP server to actually see the presentation. To convert it and immediately see it, use jupyter nbconvert notebook.ipynb --to slides --post serve This will open up the slideshow in your browser so you can present it. panda presentation: presentation","title":"Installing Jupyter Notebook"},{"location":"GettingStarted/lib/","text":"Python Libraries Following are the best Python Libraries: TensorFlow Scikit-Learn Numpy Keras PyTorch LightGBM Eli5 SciPy Theano Pandas","title":"Guide to Python Libraries"},{"location":"GettingStarted/lib/#python-libraries","text":"Following are the best Python Libraries: TensorFlow Scikit-Learn Numpy Keras PyTorch LightGBM Eli5 SciPy Theano Pandas","title":"Python Libraries"},{"location":"GettingStarted/note/","text":"Why Codes?","title":"Note"},{"location":"GettingStarted/note/#why-codes","text":"","title":"Why Codes?"},{"location":"Index/","text":"Index Why Codes? Getting started Guide to starting Python Guide to Python Libraries Fundamentals of Programming DataStructure Loops and Conditions Project Fern Project Diffusion Functions and Class Project N-charges Project Random Walk Numpy Array MeshGrid Algebra Statistics Pandas Dataframe Indexing Data Exploration GroupBy Lambda Transform","title":"Index"},{"location":"Index/#index","text":"Why Codes? Getting started Guide to starting Python Guide to Python Libraries Fundamentals of Programming DataStructure Loops and Conditions Project Fern Project Diffusion Functions and Class Project N-charges Project Random Walk Numpy Array MeshGrid Algebra Statistics Pandas Dataframe Indexing Data Exploration GroupBy Lambda Transform","title":"Index"},{"location":"References/ref/","text":"References Mkdocs Deploy MkDocs MkDoc Black and Blue Codehilit Syntax highlight all Syntax highlight code","title":"Reference"},{"location":"References/ref/#references","text":"","title":"References"},{"location":"References/ref/#mkdocs","text":"Deploy MkDocs MkDoc Black and Blue Codehilit Syntax highlight all Syntax highlight code","title":"Mkdocs"},{"location":"algebra/Five-States-Model/Five-States-Model/","text":"Eigen Value Method import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt import seaborn as sns sns . set() Five State Markov Model $${\\frac{dO(t)}{dt} = k_{io}I(t) + k_{co}C(t) - (k_{oi} + k_{oc})O(t)}$$ $${\\frac{dC(t)}{dt} = k_{oc}O(t) + k_{ic}I(t) + k_{pc}P(t) - (k_{co} + k_{ci} + k_{cp})C(t)}$$ $${\\frac{dI(t)}{dt} = k_{oi}O(t) + k_{ci}C(t) - (k_{io} + k_{ic})I(t)}$$ $${\\frac{dP(t)}{dt} = k_{cp}C(t) + k_{qp}Q(t) - (k_{pc} + k_{pq})P(t)}$$ $${\\frac{dQ(t)}{dt} = k_{pq}P(t) - k_{qp}Q(t)}$$ Using $${Q = 1 - I - C - O - P}$$ for equilibrium $${k_{io}I(t) + k_{co}C(t) - (k_{oi} + k_{oc})O(t) = 0}$$ $${k_{oc}O(t) + k_{ic}I(t) + k_{pc}P(t) - (k_{co} + k_{ci} + k_{cp})C(t) = 0}$$ $${k_{oi}O(t) + k_{ci}C(t) - (k_{io} + k_{ic})I(t) = 0}$$ $${ (k_{qp} - k_{cp})C(t) + (k_{pc} + k_{pq} + k_{qp})P(t) + k_{qp}I(t) + k_{qp}O(t) = k_{qp}}$$ Algeraic Solution $$\\left( \\begin{array}{cccc} -(k_{oi} + k_{oc}) & k_{co} & k_{io} & 0\\cr k_{oc} & - (k_{co} + k_{ci} + k_{cp}) & k_{ic} & k_{pc}\\cr k_{oi} & k_{ci} & - (k_{io} + k_{ic}) & 0\\cr k_{qp} & (k_{qp} - k_{cp}) & k_{qp} & (k_{pc} + k_{pq} + k_{qp})\\cr \\end{array} \\right) \\left( \\begin{array}{c} O\\cr C\\cr I\\cr P\\cr \\end{array} \\right) = \\left( \\begin{array}{c} 0\\cr 0\\cr 0\\cr k_{qp}\\cr \\end{array} \\right) $$ k = { \"koi\" : 0.32 ,\\ \"kio\" : 0.24 ,\\ \"kco\" : 0.31 ,\\ \"koc\" : 0.12 ,\\ \"kic\" : 0.34 ,\\ \"kci\" : 0.23 ,\\ \"kcp\" : 0.37 ,\\ \"kpc\" : 0.22 ,\\ \"kpq\" : 0.31 ,\\ \"kqp\" : 0.15 } A = np . array([[ - (k[ 'koi' ] + k[ 'koc' ]), k[ 'kco' ], k[ 'kio' ], 0 ], [k[ 'koc' ], - (k[ 'kco' ] + k[ 'kci' ] + k[ 'kcp' ]), k[ 'kic' ],k[ 'kpc' ]], [k[ 'koi' ], k[ 'kci' ], - (k[ 'kio' ] + k[ 'kic' ]), 0 ], [k[ 'kqp' ], (k[ 'kqp' ] - k[ 'kcp' ]), k[ 'kqp' ],(k[ 'kpc' ] + k[ 'kpq' ] + k[ 'kqp' ])]]) A array([[-0.44, 0.31, 0.24, 0. ], [ 0.12, -0.91, 0.34, 0.22], [ 0.32, 0.23, -0.58, 0. ], [ 0.15, -0.22, 0.15, 0.68]]) b = np . array([ 0 , 0 , 0 ,k[ 'kqp' ]]) from numpy import linalg x = np . linalg . solve(A, b) x array([0.1532031 , 0.11630397, 0.13064639, 0.19560213]) 1 - sum (x) 0.4042444074447815 Numerical Solution $${\\frac{dO(t)}{dt} = k_{io}I(t) + k_{co}C(t) - (k_{oi} + k_{oc})O(t)}$$ $${\\frac{dC(t)}{dt} = k_{oc}O(t) + k_{ic}I(t) + k_{pc}P(t) - (k_{co} + k_{ci} + k_{cp})C(t)}$$ $${\\frac{dI(t)}{dt} = k_{oi}O(t) + k_{ci}C(t) - (k_{io} + k_{ic})I(t)}$$ $${\\frac{dP(t)}{dt} = k_{cp}C(t) + k_{qp}Q(t) - (k_{pc} + k_{pq})P(t)}$$ $${Q = 1 - I - C - O - P}$$ # function that returns dy/dt def model (y,t,k): '''y[0] = O, y[1] = C, y[2] = I, y[3] = P ''' dy1dt = - (k[ 'koi' ] + k[ 'koc' ]) * y[ 0 ] + k[ 'kco' ] * y[ 1 ] + k[ 'kio' ] * y[ 2 ] dy2dt = k[ 'koc' ] * y[ 0 ] - (k[ 'kco' ] + k[ 'kci' ] + k[ 'kcp' ]) * y[ 1 ] \\ + k[ 'kic' ] * y[ 2 ] + k[ 'kpc' ] * y[ 3 ] dy3dt = k[ 'koi' ] * y[ 0 ] + k[ 'kci' ] * y[ 1 ] - (k[ 'kio' ] + k[ 'kic' ]) * y[ 2 ] dy4dt = k[ 'kqp' ] - k[ 'kqp' ] * y[ 0 ] - (k[ 'kqp' ] - k[ 'kcp' ]) * y[ 1 ] \\ - k[ 'kqp' ] * y[ 2 ] - (k[ 'kqp' ] + k[ 'kpc' ] + k[ 'kpq' ]) * y[ 3 ] dydt = [dy1dt,dy2dt,dy3dt,dy4dt] return dydt N = 1 T = 45 # initial condition y0 = [ 0 , 0 , 0 , 1 ] # time points t = np . linspace( 0 ,T) '''solve ODEs''' y = odeint(model,y0,t,args = (k,)) y1 = np . empty_like(t) y2 = np . empty_like(t) y3 = np . empty_like(t) y4 = np . empty_like(t) y5 = np . empty_like(t) for i in range ( len (t)): y1[i] = y[i][ 0 ] y2[i] = y[i][ 1 ] y3[i] = y[i][ 2 ] y4[i] = y[i][ 3 ] y5[i] = 1 - y1[i] - y2[i] - y3[i] - y4[i] y1[T],y2[T],y3[T],y4[T],y5[T] (0.15207871024029435, 0.11582562983472518, 0.12966873235864482, 0.19596397516696185, 0.4064629523993738) # plot results plt . figure(figsize = [ 12 , 5 ]) plt . plot(t,y1,linewidth = 2 ,label = 'open' ) plt . plot(t,y2,linewidth = 2 ,label = 'closed' ) plt . plot(t,y3,linewidth = 2 ,label = 'inactive' ) plt . plot(t,y4,linewidth = 2 ,label = 'P' ) plt . plot(t,y5,linewidth = 2 ,label = 'Q' ) plt . xlabel( 'time' ) plt . ylabel( 'y(t)' ) plt . legend() plt . show()","title":"Five States Model"},{"location":"algebra/Five-States-Model/Five-States-Model/#eigen-value-method","text":"import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt import seaborn as sns sns . set()","title":"Eigen Value Method"},{"location":"algebra/Five-States-Model/Five-States-Model/#five-state-markov-model","text":"$${\\frac{dO(t)}{dt} = k_{io}I(t) + k_{co}C(t) - (k_{oi} + k_{oc})O(t)}$$ $${\\frac{dC(t)}{dt} = k_{oc}O(t) + k_{ic}I(t) + k_{pc}P(t) - (k_{co} + k_{ci} + k_{cp})C(t)}$$ $${\\frac{dI(t)}{dt} = k_{oi}O(t) + k_{ci}C(t) - (k_{io} + k_{ic})I(t)}$$ $${\\frac{dP(t)}{dt} = k_{cp}C(t) + k_{qp}Q(t) - (k_{pc} + k_{pq})P(t)}$$ $${\\frac{dQ(t)}{dt} = k_{pq}P(t) - k_{qp}Q(t)}$$ Using $${Q = 1 - I - C - O - P}$$ for equilibrium $${k_{io}I(t) + k_{co}C(t) - (k_{oi} + k_{oc})O(t) = 0}$$ $${k_{oc}O(t) + k_{ic}I(t) + k_{pc}P(t) - (k_{co} + k_{ci} + k_{cp})C(t) = 0}$$ $${k_{oi}O(t) + k_{ci}C(t) - (k_{io} + k_{ic})I(t) = 0}$$ $${ (k_{qp} - k_{cp})C(t) + (k_{pc} + k_{pq} + k_{qp})P(t) + k_{qp}I(t) + k_{qp}O(t) = k_{qp}}$$","title":"Five State Markov Model"},{"location":"algebra/Five-States-Model/Five-States-Model/#algeraic-solution","text":"$$\\left( \\begin{array}{cccc} -(k_{oi} + k_{oc}) & k_{co} & k_{io} & 0\\cr k_{oc} & - (k_{co} + k_{ci} + k_{cp}) & k_{ic} & k_{pc}\\cr k_{oi} & k_{ci} & - (k_{io} + k_{ic}) & 0\\cr k_{qp} & (k_{qp} - k_{cp}) & k_{qp} & (k_{pc} + k_{pq} + k_{qp})\\cr \\end{array} \\right) \\left( \\begin{array}{c} O\\cr C\\cr I\\cr P\\cr \\end{array} \\right) = \\left( \\begin{array}{c} 0\\cr 0\\cr 0\\cr k_{qp}\\cr \\end{array} \\right) $$ k = { \"koi\" : 0.32 ,\\ \"kio\" : 0.24 ,\\ \"kco\" : 0.31 ,\\ \"koc\" : 0.12 ,\\ \"kic\" : 0.34 ,\\ \"kci\" : 0.23 ,\\ \"kcp\" : 0.37 ,\\ \"kpc\" : 0.22 ,\\ \"kpq\" : 0.31 ,\\ \"kqp\" : 0.15 } A = np . array([[ - (k[ 'koi' ] + k[ 'koc' ]), k[ 'kco' ], k[ 'kio' ], 0 ], [k[ 'koc' ], - (k[ 'kco' ] + k[ 'kci' ] + k[ 'kcp' ]), k[ 'kic' ],k[ 'kpc' ]], [k[ 'koi' ], k[ 'kci' ], - (k[ 'kio' ] + k[ 'kic' ]), 0 ], [k[ 'kqp' ], (k[ 'kqp' ] - k[ 'kcp' ]), k[ 'kqp' ],(k[ 'kpc' ] + k[ 'kpq' ] + k[ 'kqp' ])]]) A array([[-0.44, 0.31, 0.24, 0. ], [ 0.12, -0.91, 0.34, 0.22], [ 0.32, 0.23, -0.58, 0. ], [ 0.15, -0.22, 0.15, 0.68]]) b = np . array([ 0 , 0 , 0 ,k[ 'kqp' ]]) from numpy import linalg x = np . linalg . solve(A, b) x array([0.1532031 , 0.11630397, 0.13064639, 0.19560213]) 1 - sum (x) 0.4042444074447815","title":"Algeraic Solution"},{"location":"algebra/Five-States-Model/Five-States-Model/#numerical-solution","text":"$${\\frac{dO(t)}{dt} = k_{io}I(t) + k_{co}C(t) - (k_{oi} + k_{oc})O(t)}$$ $${\\frac{dC(t)}{dt} = k_{oc}O(t) + k_{ic}I(t) + k_{pc}P(t) - (k_{co} + k_{ci} + k_{cp})C(t)}$$ $${\\frac{dI(t)}{dt} = k_{oi}O(t) + k_{ci}C(t) - (k_{io} + k_{ic})I(t)}$$ $${\\frac{dP(t)}{dt} = k_{cp}C(t) + k_{qp}Q(t) - (k_{pc} + k_{pq})P(t)}$$ $${Q = 1 - I - C - O - P}$$ # function that returns dy/dt def model (y,t,k): '''y[0] = O, y[1] = C, y[2] = I, y[3] = P ''' dy1dt = - (k[ 'koi' ] + k[ 'koc' ]) * y[ 0 ] + k[ 'kco' ] * y[ 1 ] + k[ 'kio' ] * y[ 2 ] dy2dt = k[ 'koc' ] * y[ 0 ] - (k[ 'kco' ] + k[ 'kci' ] + k[ 'kcp' ]) * y[ 1 ] \\ + k[ 'kic' ] * y[ 2 ] + k[ 'kpc' ] * y[ 3 ] dy3dt = k[ 'koi' ] * y[ 0 ] + k[ 'kci' ] * y[ 1 ] - (k[ 'kio' ] + k[ 'kic' ]) * y[ 2 ] dy4dt = k[ 'kqp' ] - k[ 'kqp' ] * y[ 0 ] - (k[ 'kqp' ] - k[ 'kcp' ]) * y[ 1 ] \\ - k[ 'kqp' ] * y[ 2 ] - (k[ 'kqp' ] + k[ 'kpc' ] + k[ 'kpq' ]) * y[ 3 ] dydt = [dy1dt,dy2dt,dy3dt,dy4dt] return dydt N = 1 T = 45 # initial condition y0 = [ 0 , 0 , 0 , 1 ] # time points t = np . linspace( 0 ,T) '''solve ODEs''' y = odeint(model,y0,t,args = (k,)) y1 = np . empty_like(t) y2 = np . empty_like(t) y3 = np . empty_like(t) y4 = np . empty_like(t) y5 = np . empty_like(t) for i in range ( len (t)): y1[i] = y[i][ 0 ] y2[i] = y[i][ 1 ] y3[i] = y[i][ 2 ] y4[i] = y[i][ 3 ] y5[i] = 1 - y1[i] - y2[i] - y3[i] - y4[i] y1[T],y2[T],y3[T],y4[T],y5[T] (0.15207871024029435, 0.11582562983472518, 0.12966873235864482, 0.19596397516696185, 0.4064629523993738) # plot results plt . figure(figsize = [ 12 , 5 ]) plt . plot(t,y1,linewidth = 2 ,label = 'open' ) plt . plot(t,y2,linewidth = 2 ,label = 'closed' ) plt . plot(t,y3,linewidth = 2 ,label = 'inactive' ) plt . plot(t,y4,linewidth = 2 ,label = 'P' ) plt . plot(t,y5,linewidth = 2 ,label = 'Q' ) plt . xlabel( 'time' ) plt . ylabel( 'y(t)' ) plt . legend() plt . show()","title":"Numerical Solution"},{"location":"markov/Four States Model/Four States Model/","text":"Four State Markov Model import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns sns . set() % matplotlib inline Model Parameter k_ab,k_ac,k_ad = 0.53 , 0.62 , 0.34 k_ba,k_bc,k_bd = 0.37 , 0.72 , 0.44 k_ca,k_cb,k_cd = 0.61 , 0.76 , 0.53 k_da,k_db,k_dc = 0.35 , 0.54 , 0.66 dt = 0.01 1. Monte Carlo Simulation Monte carlo simulation is a technique to generate samples based on certain distribution. In statistical Mechanics I used this technique to simulate the system of gas ( Idle and real gas) where we used the Blotzman fraction (based on Hamiltonian of the system Exp(E/KT)) for simulation. In our case, for each of the state we have probability distribution vector. For example if the current state is in state \u201cA\u201d. The probability vector is [$K_{aa} dt, K_{ab} dt, K_{ac} dt, K_{ad} dt$] which represents the probability for state to remain at \u2018A\u2019, go to \u2018B\u2019,'C' state and go to \u2018D\u2019 state respectively. How do we do monte carlo simulation? We start with N number of ion channels. For each ion channel we create a Markov chain like ---A---C---B---B---D---- time 0 to T. In this Markov chain, generation of every new state is totally based on current state only. Not on the history of the past states (Red cross X). Due to this property, it is called memoryless chain of states. From simulated data, we can calculate the fraction of the states out of N channels. We can calculate this for any instant of time and make a plot to see whether there is equilibrium or not. M = { \"A\" : [ 1 - (k_ab + k_ac + k_ad) * dt, k_ab * dt, k_ac * dt, k_ad * dt], \"B\" : [k_ba * dt, 1 - (k_ba + k_bc + k_bd) * dt, k_bc * dt, k_bd * dt], \"C\" : [k_ca * dt, k_cb * dt, 1 - (k_ca + k_cb + k_cd) * dt, k_cd * dt], \"D\" : [k_da * dt, k_db * dt, k_dc * dt, 1 - (k_da + k_db + k_dc) * dt]} states = [ \"A\" , \"B\" , \"C\" , \"D\" ] M[ \"A\" ],M[ \"B\" ],M[ \"C\" ],M[ \"D\" ] ([0.9851, 0.0053, 0.0062, 0.0034000000000000002], [0.0037, 0.9847, 0.0072, 0.0044], [0.0061, 0.0076, 0.981, 0.0053], [0.0034999999999999996, 0.0054, 0.006600000000000001, 0.9845]) Simulation current_state = \"A\" T = 1000 N = 10000 SS = [[ \"A\" for n in range (T)] for t in range (N)] for n in range (N): na,nb,nc,nd = 0 , 0 , 0 , 0 for t in range (T): new_state = np . random . choice(states, p = M[current_state]) #print(new_state) SS[n][t] = new_state current_state = new_state ss = np . array(SS) Data = [] X = [] for t in range (T): X . append(t) a = list (ss[:,t]) . count( \"A\" ) / float (N) b = list (ss[:,t]) . count( \"B\" ) / float (N) c = list (ss[:,t]) . count( \"C\" ) / float (N) d = list (ss[:,t]) . count( \"D\" ) / float (N) Data . append({ \"A\" :a, \"B\" :b, \"C\" :c, \"D\" :d}) Data Frame DF = pd . DataFrame(Data) DF . head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 0.2346 0.2863 0.2580 0.2211 1 0.2351 0.2874 0.2580 0.2195 2 0.2344 0.2884 0.2556 0.2216 3 0.2339 0.2882 0.2565 0.2214 4 0.2341 0.2882 0.2562 0.2215 DF . plot(figsize = [ 12 , 8 ]) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a1bf340b8&gt; A = 0.23021616 B = 0.28749159 C = 0.26095346 D = 0.22999999999999998 2. Analytical Solution $\\large{A = \\frac{1}{1 + \\frac{k_{ab}}{k_{ba}} + \\frac{k_{ac}}{k_{ca}} + \\frac{k_{ad}}{k_{da}} }}$ 1 / ( 1 + (k_ab / k_ba) + (k_ac / k_ca) + (k_ad / k_da)) 0.22623132041537555 $\\large{B = \\frac{\\frac{k_{ab}}{k_{ba}}}{1 + \\frac{k_{ab}}{k_{ba}} + \\frac{k_{ac}}{k_{ca}} + \\frac{k_{ad}}{k_{da}} }}$ (k_ab / k_ba) / ( 1 + (k_ab / k_ba) + (k_ac / k_ca) + (k_ad / k_da)) 0.3240610805949974 $\\large{C = \\frac{\\frac{k_{ac}}{k_{ca}}}{1 + \\frac{k_{ab}}{k_{ba}} + \\frac{k_{ac}}{k_{ca}} + \\frac{k_{ad}}{k_{da}} }}$ (k_ac / k_ca) / ( 1 + (k_ab / k_ba) + (k_ac / k_ca) + (k_ad / k_da)) 0.22994003058611942 $\\large{D = \\frac{\\frac{k_{ad}}{k_{da}}}{1 + \\frac{k_{ab}}{k_{ba}} + \\frac{k_{ac}}{k_{ca}} + \\frac{k_{ad}}{k_{da}} }}$ (k_ad / k_da) / ( 1 + (k_ab / k_ba) + (k_ac / k_ca) + (k_ad / k_da)) 0.2197675684035077 Linear Algebra Approach B = np . array([[(k_ab + k_ac + k_ad + k_da), (k_da - k_ba), (k_da - k_ca)], [(k_db - k_ab), (k_ba + k_bc + k_bd + k_db), (k_db - k_cb)], [(k_dc - k_ac), (k_dc - k_bc), (k_ca + k_cb + k_cd + k_dc)]]) b = np . array([k_da,k_db,k_dc]) Binv = np . linalg . inv(B) np . dot(Binv,b), 1 - 0.23 - 0.28 - 0.26 (array([0.23021616, 0.28749159, 0.26095346]), 0.22999999999999998)","title":"Four States"},{"location":"markov/Four States Model/Four States Model/#four-state-markov-model","text":"import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns sns . set() % matplotlib inline","title":"Four State Markov Model"},{"location":"markov/Four States Model/Four States Model/#model-parameter","text":"k_ab,k_ac,k_ad = 0.53 , 0.62 , 0.34 k_ba,k_bc,k_bd = 0.37 , 0.72 , 0.44 k_ca,k_cb,k_cd = 0.61 , 0.76 , 0.53 k_da,k_db,k_dc = 0.35 , 0.54 , 0.66 dt = 0.01","title":"Model Parameter"},{"location":"markov/Four States Model/Four States Model/#1-monte-carlo-simulation","text":"Monte carlo simulation is a technique to generate samples based on certain distribution. In statistical Mechanics I used this technique to simulate the system of gas ( Idle and real gas) where we used the Blotzman fraction (based on Hamiltonian of the system Exp(E/KT)) for simulation. In our case, for each of the state we have probability distribution vector. For example if the current state is in state \u201cA\u201d. The probability vector is [$K_{aa} dt, K_{ab} dt, K_{ac} dt, K_{ad} dt$] which represents the probability for state to remain at \u2018A\u2019, go to \u2018B\u2019,'C' state and go to \u2018D\u2019 state respectively. How do we do monte carlo simulation? We start with N number of ion channels. For each ion channel we create a Markov chain like ---A---C---B---B---D---- time 0 to T. In this Markov chain, generation of every new state is totally based on current state only. Not on the history of the past states (Red cross X). Due to this property, it is called memoryless chain of states. From simulated data, we can calculate the fraction of the states out of N channels. We can calculate this for any instant of time and make a plot to see whether there is equilibrium or not. M = { \"A\" : [ 1 - (k_ab + k_ac + k_ad) * dt, k_ab * dt, k_ac * dt, k_ad * dt], \"B\" : [k_ba * dt, 1 - (k_ba + k_bc + k_bd) * dt, k_bc * dt, k_bd * dt], \"C\" : [k_ca * dt, k_cb * dt, 1 - (k_ca + k_cb + k_cd) * dt, k_cd * dt], \"D\" : [k_da * dt, k_db * dt, k_dc * dt, 1 - (k_da + k_db + k_dc) * dt]} states = [ \"A\" , \"B\" , \"C\" , \"D\" ] M[ \"A\" ],M[ \"B\" ],M[ \"C\" ],M[ \"D\" ] ([0.9851, 0.0053, 0.0062, 0.0034000000000000002], [0.0037, 0.9847, 0.0072, 0.0044], [0.0061, 0.0076, 0.981, 0.0053], [0.0034999999999999996, 0.0054, 0.006600000000000001, 0.9845])","title":"1. Monte Carlo Simulation"},{"location":"markov/Four States Model/Four States Model/#simulation","text":"current_state = \"A\" T = 1000 N = 10000 SS = [[ \"A\" for n in range (T)] for t in range (N)] for n in range (N): na,nb,nc,nd = 0 , 0 , 0 , 0 for t in range (T): new_state = np . random . choice(states, p = M[current_state]) #print(new_state) SS[n][t] = new_state current_state = new_state ss = np . array(SS) Data = [] X = [] for t in range (T): X . append(t) a = list (ss[:,t]) . count( \"A\" ) / float (N) b = list (ss[:,t]) . count( \"B\" ) / float (N) c = list (ss[:,t]) . count( \"C\" ) / float (N) d = list (ss[:,t]) . count( \"D\" ) / float (N) Data . append({ \"A\" :a, \"B\" :b, \"C\" :c, \"D\" :d})","title":"Simulation"},{"location":"markov/Four States Model/Four States Model/#data-frame","text":"DF = pd . DataFrame(Data) DF . head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 0.2346 0.2863 0.2580 0.2211 1 0.2351 0.2874 0.2580 0.2195 2 0.2344 0.2884 0.2556 0.2216 3 0.2339 0.2882 0.2565 0.2214 4 0.2341 0.2882 0.2562 0.2215 DF . plot(figsize = [ 12 , 8 ]) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a1bf340b8&gt; A = 0.23021616 B = 0.28749159 C = 0.26095346 D = 0.22999999999999998","title":"Data Frame"},{"location":"markov/Four States Model/Four States Model/#2-analytical-solution","text":"$\\large{A = \\frac{1}{1 + \\frac{k_{ab}}{k_{ba}} + \\frac{k_{ac}}{k_{ca}} + \\frac{k_{ad}}{k_{da}} }}$ 1 / ( 1 + (k_ab / k_ba) + (k_ac / k_ca) + (k_ad / k_da)) 0.22623132041537555 $\\large{B = \\frac{\\frac{k_{ab}}{k_{ba}}}{1 + \\frac{k_{ab}}{k_{ba}} + \\frac{k_{ac}}{k_{ca}} + \\frac{k_{ad}}{k_{da}} }}$ (k_ab / k_ba) / ( 1 + (k_ab / k_ba) + (k_ac / k_ca) + (k_ad / k_da)) 0.3240610805949974 $\\large{C = \\frac{\\frac{k_{ac}}{k_{ca}}}{1 + \\frac{k_{ab}}{k_{ba}} + \\frac{k_{ac}}{k_{ca}} + \\frac{k_{ad}}{k_{da}} }}$ (k_ac / k_ca) / ( 1 + (k_ab / k_ba) + (k_ac / k_ca) + (k_ad / k_da)) 0.22994003058611942 $\\large{D = \\frac{\\frac{k_{ad}}{k_{da}}}{1 + \\frac{k_{ab}}{k_{ba}} + \\frac{k_{ac}}{k_{ca}} + \\frac{k_{ad}}{k_{da}} }}$ (k_ad / k_da) / ( 1 + (k_ab / k_ba) + (k_ac / k_ca) + (k_ad / k_da)) 0.2197675684035077","title":"2. Analytical Solution"},{"location":"markov/Four States Model/Four States Model/#linear-algebra-approach","text":"B = np . array([[(k_ab + k_ac + k_ad + k_da), (k_da - k_ba), (k_da - k_ca)], [(k_db - k_ab), (k_ba + k_bc + k_bd + k_db), (k_db - k_cb)], [(k_dc - k_ac), (k_dc - k_bc), (k_ca + k_cb + k_cd + k_dc)]]) b = np . array([k_da,k_db,k_dc]) Binv = np . linalg . inv(B) np . dot(Binv,b), 1 - 0.23 - 0.28 - 0.26 (array([0.23021616, 0.28749159, 0.26095346]), 0.22999999999999998)","title":"Linear Algebra Approach"},{"location":"markov/Random Process/Random Process/","text":"Introduction to Random Process Random Process - A rando process in which we can deterministically find the state of each random variable given the initial conditions are known as deterministic random processes (height of a bouncing ball). - A random processes, in which we can't determine the state of a process, even if we are given the initial conditions and all the parameters of the system, are known as stochastic random processes (stock market) Q: Generate a deterministic random process example using gaussian noise over a sine wave. import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns . set() mu = 0 , sigma = 0.1 x = np . arange( - np . pi, np . pi, 0.1 ) s = np . random . normal(mu, sigma, len (x)) y = np . sin(x) + s yy = np . sin(x) len (s), len (s) (63, 63) plt . figure(figsize = [ 10 , 6 ]) plt . plot(x,y, '-' ) plt . plot(x,yy, \"-\" ) plt . scatter(x,y) plt . show() Q: Generate a stocastic random process example using random walk in 1d. import random as random '''X stores 1-D coordinate''' X = [] '''T stores time coordinate''' T = [] '''starting point''' x = 0 '''length of each step''' d = 1 '''iteratefor N steps''' for t in range ( 100 ): '''Walk one step ahead''' x = x + d * random . choice([ - 1 , 1 ]) '''collect time''' T . append(t) '''collect position''' X . append(x) '''Make a plot''' plt . figure(figsize = [ 12 , 6 ]) plt . scatter(T,X,marker = '.' ) plt . plot(T,X) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . show() Markov Process A stochastic process is called a Markov process if the state of the random variable at the next instance of time depends only on the outcome of the random variable at the current time. In simplistic mathematical terms, for a stochastic process, $S = {R_1, R_2, . . ., R_n} = {R}_{t=1, . . ., n}$, to be a Markov process, it must satisfy the following condition: $P(R_{n+1} | R_1, R_2,..., R_n) = P(R_{n+1} | R_n)$ According to the previous condition, the probability distribution for any variable at any given instance in a Markov process is a conditional distribution, which is conditioned only on the random variable at the last time instance. This property of a system, such that the future states of the system depend only on the current state of the system , is also known as the Markov property . Systems satisfying the Markov property are also known as memoryless systems since they don't need to remember the previous states to compute the distribution of the next state, or, in other words, the next state depends only on the current state of the system. Discrite Time Markov Process import numpy as np class MarkovChain ( object ): def __init__ ( self , transition_prob): \"\"\" Initialize the MarkovChain instance. Parameters ---------- transition_prob: dict A dict object representing the transition probabilities in Markov Chain. Should be of the form: {'state1': {'state1': 0.1, 'state2': 0.4}, 'state2': {...}} \"\"\" self . transition_prob = transition_prob self . states = list (transition_prob . keys()) def next_state ( self , current_state): \"\"\" Returns the state of the random variable at the next time instance. Parameters ---------- current_state: str The current state of the system. \"\"\" return np . random . choice( self . states, p = [ self . transition_prob[current_state][next_state] for next_state in self . states]) def generate_states ( self , current_state, no = 10 ): \"\"\" Generates the next states of the system. Parameters ---------- current_state: str The state of the current random variable. no: int The number of future states to generate. \"\"\" future_states = [] for i in range (no): next_state = self . next_state(current_state) future_states . append(next_state) current_state = next_state return future_states weather_chain = MarkovChain(transition_prob = transition_prob) transition_prob = { 'Sunny' : { 'Sunny' : 0.8 , 'Rainy' : 0.19 , 'Snowy' : 0.01 }, 'Rainy' : { 'Sunny' : 0.2 , 'Rainy' : 0.7 , 'Snowy' : 0.1 }, 'Snowy' : { 'Sunny' : 0.1 , 'Rainy' : 0.2 , 'Snowy' : 0.7 }} DAYS = weather_chain . generate_states(current_state = 'Snowy' , no = 100 ) Q: How does tempersture fluctuate ? Temp = { \"Snowy\" : 0 , \"Rainy\" : 10 , \"Sunny\" : 20 } X,Y = [],[] plt . figure(figsize = [ 16 , 4 ]) for i,day in enumerate (DAYS): X . append(i) Y . append(Temp[day]) plt . plot(X,Y, \"-\" ) plt . scatter(X,Y) plt . show()","title":"Random Process"},{"location":"markov/Random Process/Random Process/#introduction-to-random-process","text":"Random Process - A rando process in which we can deterministically find the state of each random variable given the initial conditions are known as deterministic random processes (height of a bouncing ball). - A random processes, in which we can't determine the state of a process, even if we are given the initial conditions and all the parameters of the system, are known as stochastic random processes (stock market)","title":"Introduction to Random Process"},{"location":"markov/Random Process/Random Process/#q-generate-a-deterministic-random-process-example-using-gaussian-noise-over-a-sine-wave","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns . set() mu = 0 , sigma = 0.1 x = np . arange( - np . pi, np . pi, 0.1 ) s = np . random . normal(mu, sigma, len (x)) y = np . sin(x) + s yy = np . sin(x) len (s), len (s) (63, 63) plt . figure(figsize = [ 10 , 6 ]) plt . plot(x,y, '-' ) plt . plot(x,yy, \"-\" ) plt . scatter(x,y) plt . show()","title":"Q: Generate a deterministic random process example using gaussian noise over a sine wave."},{"location":"markov/Random Process/Random Process/#q-generate-a-stocastic-random-process-example-using-random-walk-in-1d","text":"import random as random '''X stores 1-D coordinate''' X = [] '''T stores time coordinate''' T = [] '''starting point''' x = 0 '''length of each step''' d = 1 '''iteratefor N steps''' for t in range ( 100 ): '''Walk one step ahead''' x = x + d * random . choice([ - 1 , 1 ]) '''collect time''' T . append(t) '''collect position''' X . append(x) '''Make a plot''' plt . figure(figsize = [ 12 , 6 ]) plt . scatter(T,X,marker = '.' ) plt . plot(T,X) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . show()","title":"Q: Generate a stocastic random process example using random walk in 1d."},{"location":"markov/Random Process/Random Process/#markov-process","text":"A stochastic process is called a Markov process if the state of the random variable at the next instance of time depends only on the outcome of the random variable at the current time. In simplistic mathematical terms, for a stochastic process, $S = {R_1, R_2, . . ., R_n} = {R}_{t=1, . . ., n}$, to be a Markov process, it must satisfy the following condition: $P(R_{n+1} | R_1, R_2,..., R_n) = P(R_{n+1} | R_n)$ According to the previous condition, the probability distribution for any variable at any given instance in a Markov process is a conditional distribution, which is conditioned only on the random variable at the last time instance. This property of a system, such that the future states of the system depend only on the current state of the system , is also known as the Markov property . Systems satisfying the Markov property are also known as memoryless systems since they don't need to remember the previous states to compute the distribution of the next state, or, in other words, the next state depends only on the current state of the system.","title":"Markov Process"},{"location":"markov/Random Process/Random Process/#discrite-time-markov-process","text":"import numpy as np class MarkovChain ( object ): def __init__ ( self , transition_prob): \"\"\" Initialize the MarkovChain instance. Parameters ---------- transition_prob: dict A dict object representing the transition probabilities in Markov Chain. Should be of the form: {'state1': {'state1': 0.1, 'state2': 0.4}, 'state2': {...}} \"\"\" self . transition_prob = transition_prob self . states = list (transition_prob . keys()) def next_state ( self , current_state): \"\"\" Returns the state of the random variable at the next time instance. Parameters ---------- current_state: str The current state of the system. \"\"\" return np . random . choice( self . states, p = [ self . transition_prob[current_state][next_state] for next_state in self . states]) def generate_states ( self , current_state, no = 10 ): \"\"\" Generates the next states of the system. Parameters ---------- current_state: str The state of the current random variable. no: int The number of future states to generate. \"\"\" future_states = [] for i in range (no): next_state = self . next_state(current_state) future_states . append(next_state) current_state = next_state return future_states weather_chain = MarkovChain(transition_prob = transition_prob) transition_prob = { 'Sunny' : { 'Sunny' : 0.8 , 'Rainy' : 0.19 , 'Snowy' : 0.01 }, 'Rainy' : { 'Sunny' : 0.2 , 'Rainy' : 0.7 , 'Snowy' : 0.1 }, 'Snowy' : { 'Sunny' : 0.1 , 'Rainy' : 0.2 , 'Snowy' : 0.7 }} DAYS = weather_chain . generate_states(current_state = 'Snowy' , no = 100 ) Q: How does tempersture fluctuate ? Temp = { \"Snowy\" : 0 , \"Rainy\" : 10 , \"Sunny\" : 20 } X,Y = [],[] plt . figure(figsize = [ 16 , 4 ]) for i,day in enumerate (DAYS): X . append(i) Y . append(Temp[day]) plt . plot(X,Y, \"-\" ) plt . scatter(X,Y) plt . show()","title":"Discrite Time Markov Process"},{"location":"markov/Random States/Random States/","text":"Random States import random as random import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns . set() % matplotlib inline Choosing random states We can apply python library called 'random' to choose random states out of provided states like 'O' and 'C'. allstate = [] for i in range ( 10000 ): allstate . append(random . choice([ \"O\" , \"C\" ])) #print(s) len (allstate) 10000 allstate . count( \"O\" ) 4960 allstate . count( \"C\" ) 5040 This shows that randomly choosed states out of 2 states are 50-50 % in distribution Choosing Random states with weighted probability We can choose random states with weighted probability np . random . choice([ \"O\" , \"c\" ],p = [ 0.9 , 0.1 ]) 'O' allstate = [] for i in range ( 10000 ): allstate . append(np . random . choice([ \"O\" , \"C\" ],p = [ 0.9 , 0.1 ])) len (allstate) 10000 allstate . count( \"C\" ) 1017 allstate . count( \"O\" ) 8983 Plot a Markov Chain allstate = [] for i in range ( 100 ): allstate . append(np . random . choice([ \"O\" , \"C\" ],p = [ 0.4 , 0.6 ])) plt . figure(figsize = [ 14 , 4 ]) X = [] Y = [] for x,y in enumerate (allstate): plt . scatter(x,y) X . append(x) Y . append(y) plt . plot(X,Y) plt . show()","title":"Random States"},{"location":"markov/Random States/Random States/#random-states","text":"import random as random import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns . set() % matplotlib inline","title":"Random States"},{"location":"markov/Random States/Random States/#choosing-random-states","text":"We can apply python library called 'random' to choose random states out of provided states like 'O' and 'C'. allstate = [] for i in range ( 10000 ): allstate . append(random . choice([ \"O\" , \"C\" ])) #print(s) len (allstate) 10000 allstate . count( \"O\" ) 4960 allstate . count( \"C\" ) 5040 This shows that randomly choosed states out of 2 states are 50-50 % in distribution","title":"Choosing random states"},{"location":"markov/Random States/Random States/#choosing-random-states-with-weighted-probability","text":"We can choose random states with weighted probability np . random . choice([ \"O\" , \"c\" ],p = [ 0.9 , 0.1 ]) 'O' allstate = [] for i in range ( 10000 ): allstate . append(np . random . choice([ \"O\" , \"C\" ],p = [ 0.9 , 0.1 ])) len (allstate) 10000 allstate . count( \"C\" ) 1017 allstate . count( \"O\" ) 8983","title":"Choosing Random states with weighted probability"},{"location":"markov/Random States/Random States/#plot-a-markov-chain","text":"allstate = [] for i in range ( 100 ): allstate . append(np . random . choice([ \"O\" , \"C\" ],p = [ 0.4 , 0.6 ])) plt . figure(figsize = [ 14 , 4 ]) X = [] Y = [] for x,y in enumerate (allstate): plt . scatter(x,y) X . append(x) Y . append(y) plt . plot(X,Y) plt . show()","title":"Plot a Markov Chain"},{"location":"markov/Three States Model/Three States Model/","text":"Three States Markov Model import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns sns . set() % matplotlib inline Consider a 3 state Markov model as shown in the figure below. Master Equation of Three State Model C ,O, I: fraction of states in closed, open and inactive state /( K_{ci} /) = rate of transition from state C to state I and so on Condition of Equilibrium : Influx is equal to outflux $$K_{co}.C = K_{oc}.O$$ $$K_{oi}.O = K_{io}.I$$ $$K_{ic}.I = K_{ci}.C$$ The condition of detailed balance : $$K_{co}.K_{oi}.K_{ic} = K_{oc}.K_{io}.K_{ci}$$ I.e. The total transitions in clockwise direction is equal to total transitions in counter clockwise direction Central task: Can we derive the fraction of states at equilibrium? Answer: Yes, but for large degrees of freedom (states), it is tedious. We need method of simulation or numerical methods: Simultaneous differential equations Algebric Methods For equilibrium condition, we get $$k_{co} c = k_{oc} o => c = \\frac{k_{oc}}{k_{co}}o$$ $$k_{oi} o = k_{io} i => i = \\frac{k_{oi}}{k_{io}}o$$ $$k_{ic} i = k_{ci} c$$ $$ o + c + i = 1$$ Analytical Solution Identifying equilibrium condition and calculation of the fraction of states is important for calculation of ion concentration inside and outside of the membrane (for example outward sodium current or inward calcium current). Potential gradient between in and out of the membrane etc. An ion channel can be any state at any time. The rate constants like (K_ab) which represents the rate of transition from state A to B. Channel may take fraction of time to go from one state to another. In that situation the rate constant is modified by K*dt (for example in Monte Carlo simulation) Why do we need condition of equilibrium? The real biological system is assumed to be equilibrium at a given environment. For a specific protocol, we can calculate the rate constants from experiments and design the models based on those rate constants and available states (Open, Closed, Inactive etc). Model give us further insights to understand the dynamics of the system. Statistical calculations like finding fraction of states at a given time or any other average values are possible only when there is an equilibrium. How do we know whether it is equilibrium or not? In fact, at equilibrium there is constant flow from one state to another state. It feels like there is no extra accumulation over a specific state. This is represented by equations like /( N K_{co} C = N K_{oc} O /). I.e. Consider N ion Channels, the population transitioning from C state to O is equal to the population transitioning from O to C state. Implementing three different conditions of equilibrium, one can derive the single equation called the \u201cprinciple of detailed balance\u201d. Which means the flow of states in a clockwise direction is equal to the flow in anticlockwise direction. Using the above conditions, we can easily derive the fraction of states in terms of rate constants. It is not practical to find analytical solution like this in case of large no of states. Some Computational technique is required. For system which can be brought to the equilibrium condition, there exist different ways to solve : MonteCarlo Simulation, Numerical Methods ( Simultaneous differential equations, Algebraic methods). We can also study the system not in equilibrium where simultaneous differential equation method can be used but it leads to chaotic system for example arrhythmia, long QT syndrome etc. k_oi,k_oc = 0.5 , 0.9 k_io,k_ic = 0.3 , 0.72 k_co,k_ci = 0.6 , 0.8 dt = 0.01 $$\\large{O = \\frac{1}{1 + \\frac{k_{oc}}{k_{co}} + \\frac{k_{oi}}{k_{io}}}}$$ 1 / ( 1 + (k_oc / k_co) + (k_oi / k_io)) 0.24 $$\\large{C = \\frac{\\frac{k_{oc}}{k_{co}}}{1 + \\frac{k_{oc}}{k_{co}} + \\frac{k_{oi}}{k_{io}}}}$$ (k_oc / k_co) / ( 1 + (k_oc / k_co) + (k_oi / k_io)) 0.36 $$\\large{I = \\frac{\\frac{k_{oi}}{k_{io}}}{1 + \\frac{k_{oc}}{k_{co}} + \\frac{k_{oi}}{k_{io}}}}$$ (k_oi / k_io) / ( 1 + (k_oc / k_co) + (k_oi / k_io)) 0.39999999999999997 Monte Carlo Simulation Monte carlo simulation is a technique to generate samples based on certain distribution. In statistical Mechanics we use this technique to simulate the system of gas ( idle and real gas) where we used the Blotzman fraction (based on Hamiltonian of the system $(\\exp(E/KT)$) for simulation. In our case, for each of the state we have probability distribution vector. For example if the current state is in state \u201cO\u201d. The probability vector is /([K_{oo} dt, K_{oc} dt, K_{oi}*dt/)$ which represents the probability for state to remain at \u2018O\u2019, go to \u2018C\u2019 state and go to \u2018I\u2019 state respectively. How do we do monte carlo simulation? - We start with N number of ion channels. - For each ion channel we create a Markov chain like ---O---C---I---i---O---- time 0 to T. In this Markov chain, generation of every new state is totally based on current state only. Not on the history of the past states (Red cross X). Due to this property, it is called memoryless chain of states. - From simulated data, we can calculate the fraction of the states out of N channels. We can calculate this for any instant of time and make a plot to see whether there is equilibrium or not. Central task : Can we derive the fraction of states at equilibrium? Yes, following are the steps: - Start with N random ion channels - For each channel, generate a new state based on conditional probability. - At given point of time calculate the fraction of each state out of total population N along with statistical error and plot the result over time - Find out the equilibrium and mean fluctuation (standard deviation). Clue: By increasing total population (N), fluctuation can be reduced The biggest idea behind why method of simulation is valid for a system like muli-state ion channel is \u201cPrinciple of ergodicity\u201d. Which means observation of a single ion channel for a very long time (T -> infty) is equivalent to the observation of large number of ion channels (N-> infty) at a specific time. The first table is a collection of rate constant. Where as the second table is for comparison of analytical solution and expectation values from simulation. There is a certain error due to sampling through simulation where data appears to be fluctuation around the mean value equal to analytical value. One can represent the expectation value using standard error. The associated conditional probabilities can be arranged to represent weighted probability vector for each state Challenge : What is the guarantee that we will reach to the system at equilibrium starting from random initial state? The clue is Ergodicity : the time average of the system(T $\\rightarrow \\infty$) equal to the ensemble average ($N \\rightarrow \\infty$) Weighted Probability Vector We can arrange the conditional probability to create a weighted probability vactor for Monte Carlo Simulation $$P(O) = [1-(k_oc + k_oi)d\\tau, k_oc d\\tau, k_oi d\\tau]$$ $$P(C) = [k_co d\\tau, 1-(k_co + k_ci) d\\tau, k_ci d\\tau]$$ $$P(I) = [k_io d\\tau, k_ic d\\tau, 1 - (k_io + k_ic) d\\tau]$$ M = { \"O\" : [ 1 - (k_oc + k_oi) * dt, k_oc * dt, k_oi * dt], \"C\" : [k_co * dt, 1 - (k_co + k_ci) * dt, k_ci * dt], \"I\" : [k_io * dt, k_ic * dt, 1 - (k_io + k_ic) * dt]} states = [ \"O\" , \"C\" , \"I\" ] M[ \"O\" ],M[ \"C\" ],M[ \"I\" ] ([0.986, 0.009000000000000001, 0.005], [0.006, 0.986, 0.008], [0.003, 0.0072, 0.9898]) Simulation current_state = \"O\" T = 100 N = 10000 SS = [[ \"O\" for n in range (T)] for t in range (N)] for n in range (N): no,nc,ni = 0 , 0 , 0 for t in range (T): new_state = np . random . choice(states, p = M[current_state]) #print(new_state) SS[n][t] = new_state current_state = new_state Counting and Ensamble everage of states ss = np . array(SS) Data = [] X = [] for t in range (T): X . append(t) o = list (ss[:,t]) . count( \"O\" ) / float (N) c = list (ss[:,t]) . count( \"C\" ) / float (N) i = list (ss[:,t]) . count( \"I\" ) / float (N) Data . append({ \"O\" :o, \"C\" :c, \"I\" :i}) Data Frame DF = pd . DataFrame(Data) DF . head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C I O 0 0.3690 0.3933 0.2377 1 0.3688 0.3925 0.2387 2 0.3700 0.3921 0.2379 3 0.3718 0.3906 0.2376 4 0.3706 0.3907 0.2387 Mean and Standard deviation of states DF[ 'C' ] . mean(),DF[ 'C' ] . std(), (0.36810600000000016, 0.0020315103601592412) DF[ 'O' ] . mean(),DF[ 'O' ] . std(), (0.23638799999999993, 0.002197670024219635) DF[ 'I' ] . mean(),DF[ 'I' ] . std(), (0.3955060000000002, 0.00228507763500057) Plot: Equilibrium The plot represents how fraction of states fluctuate through time 0 to T. The plot shows clear equilibrium as there in no significant change in the values. As we increase the total population of ion channels (N). The error minimizes. Theoretically for N = infinity, the expectation value converges to the analytical value. # plot results plt . figure(figsize = [ 10 , 4 ]) plt . plot(X,DF[ 'O' ],color = \"orange\" ,linewidth = 2 ,label = 'open' ) plt . plot(X,DF[ 'C' ],color = \"magenta\" , linewidth = 2 ,label = 'closed' ) plt . plot(X,DF[ 'I' ],color = \"blue\" ,linewidth = 2 ,label = 'inactive' ) plt . grid( True ) plt . xlabel( 'Time(t)' ,fontsize = 15 ) plt . ylabel( 'Fraction of states: y(t)' ,fontsize = 15 ) plt . title( \"Plot of fraction of states out of N states\" ,fontsize = 15 ) plt . legend() plt . savefig( \"Sim.png\" ) plt . show() I = 0.4 C = 0.36 O = 0.24","title":"Three States"},{"location":"markov/Three States Model/Three States Model/#three-states-markov-model","text":"import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns sns . set() % matplotlib inline Consider a 3 state Markov model as shown in the figure below.","title":"Three States Markov Model"},{"location":"markov/Three States Model/Three States Model/#master-equation-of-three-state-model","text":"C ,O, I: fraction of states in closed, open and inactive state /( K_{ci} /) = rate of transition from state C to state I and so on Condition of Equilibrium : Influx is equal to outflux $$K_{co}.C = K_{oc}.O$$ $$K_{oi}.O = K_{io}.I$$ $$K_{ic}.I = K_{ci}.C$$ The condition of detailed balance : $$K_{co}.K_{oi}.K_{ic} = K_{oc}.K_{io}.K_{ci}$$ I.e. The total transitions in clockwise direction is equal to total transitions in counter clockwise direction Central task: Can we derive the fraction of states at equilibrium? Answer: Yes, but for large degrees of freedom (states), it is tedious. We need method of simulation or numerical methods: Simultaneous differential equations Algebric Methods For equilibrium condition, we get $$k_{co} c = k_{oc} o => c = \\frac{k_{oc}}{k_{co}}o$$ $$k_{oi} o = k_{io} i => i = \\frac{k_{oi}}{k_{io}}o$$ $$k_{ic} i = k_{ci} c$$ $$ o + c + i = 1$$","title":"Master Equation of Three State Model"},{"location":"markov/Three States Model/Three States Model/#analytical-solution","text":"Identifying equilibrium condition and calculation of the fraction of states is important for calculation of ion concentration inside and outside of the membrane (for example outward sodium current or inward calcium current). Potential gradient between in and out of the membrane etc. An ion channel can be any state at any time. The rate constants like (K_ab) which represents the rate of transition from state A to B. Channel may take fraction of time to go from one state to another. In that situation the rate constant is modified by K*dt (for example in Monte Carlo simulation) Why do we need condition of equilibrium? The real biological system is assumed to be equilibrium at a given environment. For a specific protocol, we can calculate the rate constants from experiments and design the models based on those rate constants and available states (Open, Closed, Inactive etc). Model give us further insights to understand the dynamics of the system. Statistical calculations like finding fraction of states at a given time or any other average values are possible only when there is an equilibrium. How do we know whether it is equilibrium or not? In fact, at equilibrium there is constant flow from one state to another state. It feels like there is no extra accumulation over a specific state. This is represented by equations like /( N K_{co} C = N K_{oc} O /). I.e. Consider N ion Channels, the population transitioning from C state to O is equal to the population transitioning from O to C state. Implementing three different conditions of equilibrium, one can derive the single equation called the \u201cprinciple of detailed balance\u201d. Which means the flow of states in a clockwise direction is equal to the flow in anticlockwise direction. Using the above conditions, we can easily derive the fraction of states in terms of rate constants. It is not practical to find analytical solution like this in case of large no of states. Some Computational technique is required. For system which can be brought to the equilibrium condition, there exist different ways to solve : MonteCarlo Simulation, Numerical Methods ( Simultaneous differential equations, Algebraic methods). We can also study the system not in equilibrium where simultaneous differential equation method can be used but it leads to chaotic system for example arrhythmia, long QT syndrome etc. k_oi,k_oc = 0.5 , 0.9 k_io,k_ic = 0.3 , 0.72 k_co,k_ci = 0.6 , 0.8 dt = 0.01 $$\\large{O = \\frac{1}{1 + \\frac{k_{oc}}{k_{co}} + \\frac{k_{oi}}{k_{io}}}}$$ 1 / ( 1 + (k_oc / k_co) + (k_oi / k_io)) 0.24 $$\\large{C = \\frac{\\frac{k_{oc}}{k_{co}}}{1 + \\frac{k_{oc}}{k_{co}} + \\frac{k_{oi}}{k_{io}}}}$$ (k_oc / k_co) / ( 1 + (k_oc / k_co) + (k_oi / k_io)) 0.36 $$\\large{I = \\frac{\\frac{k_{oi}}{k_{io}}}{1 + \\frac{k_{oc}}{k_{co}} + \\frac{k_{oi}}{k_{io}}}}$$ (k_oi / k_io) / ( 1 + (k_oc / k_co) + (k_oi / k_io)) 0.39999999999999997","title":"Analytical Solution"},{"location":"markov/Three States Model/Three States Model/#monte-carlo-simulation","text":"Monte carlo simulation is a technique to generate samples based on certain distribution. In statistical Mechanics we use this technique to simulate the system of gas ( idle and real gas) where we used the Blotzman fraction (based on Hamiltonian of the system $(\\exp(E/KT)$) for simulation. In our case, for each of the state we have probability distribution vector. For example if the current state is in state \u201cO\u201d. The probability vector is /([K_{oo} dt, K_{oc} dt, K_{oi}*dt/)$ which represents the probability for state to remain at \u2018O\u2019, go to \u2018C\u2019 state and go to \u2018I\u2019 state respectively. How do we do monte carlo simulation? - We start with N number of ion channels. - For each ion channel we create a Markov chain like ---O---C---I---i---O---- time 0 to T. In this Markov chain, generation of every new state is totally based on current state only. Not on the history of the past states (Red cross X). Due to this property, it is called memoryless chain of states. - From simulated data, we can calculate the fraction of the states out of N channels. We can calculate this for any instant of time and make a plot to see whether there is equilibrium or not. Central task : Can we derive the fraction of states at equilibrium? Yes, following are the steps: - Start with N random ion channels - For each channel, generate a new state based on conditional probability. - At given point of time calculate the fraction of each state out of total population N along with statistical error and plot the result over time - Find out the equilibrium and mean fluctuation (standard deviation). Clue: By increasing total population (N), fluctuation can be reduced The biggest idea behind why method of simulation is valid for a system like muli-state ion channel is \u201cPrinciple of ergodicity\u201d. Which means observation of a single ion channel for a very long time (T -> infty) is equivalent to the observation of large number of ion channels (N-> infty) at a specific time. The first table is a collection of rate constant. Where as the second table is for comparison of analytical solution and expectation values from simulation. There is a certain error due to sampling through simulation where data appears to be fluctuation around the mean value equal to analytical value. One can represent the expectation value using standard error. The associated conditional probabilities can be arranged to represent weighted probability vector for each state Challenge : What is the guarantee that we will reach to the system at equilibrium starting from random initial state? The clue is Ergodicity : the time average of the system(T $\\rightarrow \\infty$) equal to the ensemble average ($N \\rightarrow \\infty$)","title":"Monte Carlo Simulation"},{"location":"markov/Three States Model/Three States Model/#weighted-probability-vector","text":"We can arrange the conditional probability to create a weighted probability vactor for Monte Carlo Simulation $$P(O) = [1-(k_oc + k_oi)d\\tau, k_oc d\\tau, k_oi d\\tau]$$ $$P(C) = [k_co d\\tau, 1-(k_co + k_ci) d\\tau, k_ci d\\tau]$$ $$P(I) = [k_io d\\tau, k_ic d\\tau, 1 - (k_io + k_ic) d\\tau]$$ M = { \"O\" : [ 1 - (k_oc + k_oi) * dt, k_oc * dt, k_oi * dt], \"C\" : [k_co * dt, 1 - (k_co + k_ci) * dt, k_ci * dt], \"I\" : [k_io * dt, k_ic * dt, 1 - (k_io + k_ic) * dt]} states = [ \"O\" , \"C\" , \"I\" ] M[ \"O\" ],M[ \"C\" ],M[ \"I\" ] ([0.986, 0.009000000000000001, 0.005], [0.006, 0.986, 0.008], [0.003, 0.0072, 0.9898])","title":"Weighted Probability Vector"},{"location":"markov/Three States Model/Three States Model/#simulation","text":"current_state = \"O\" T = 100 N = 10000 SS = [[ \"O\" for n in range (T)] for t in range (N)] for n in range (N): no,nc,ni = 0 , 0 , 0 for t in range (T): new_state = np . random . choice(states, p = M[current_state]) #print(new_state) SS[n][t] = new_state current_state = new_state","title":"Simulation"},{"location":"markov/Three States Model/Three States Model/#counting-and-ensamble-everage-of-states","text":"ss = np . array(SS) Data = [] X = [] for t in range (T): X . append(t) o = list (ss[:,t]) . count( \"O\" ) / float (N) c = list (ss[:,t]) . count( \"C\" ) / float (N) i = list (ss[:,t]) . count( \"I\" ) / float (N) Data . append({ \"O\" :o, \"C\" :c, \"I\" :i})","title":"Counting and Ensamble everage of states"},{"location":"markov/Three States Model/Three States Model/#data-frame","text":"DF = pd . DataFrame(Data) DF . head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C I O 0 0.3690 0.3933 0.2377 1 0.3688 0.3925 0.2387 2 0.3700 0.3921 0.2379 3 0.3718 0.3906 0.2376 4 0.3706 0.3907 0.2387","title":"Data Frame"},{"location":"markov/Three States Model/Three States Model/#mean-and-standard-deviation-of-states","text":"DF[ 'C' ] . mean(),DF[ 'C' ] . std(), (0.36810600000000016, 0.0020315103601592412) DF[ 'O' ] . mean(),DF[ 'O' ] . std(), (0.23638799999999993, 0.002197670024219635) DF[ 'I' ] . mean(),DF[ 'I' ] . std(), (0.3955060000000002, 0.00228507763500057)","title":"Mean and Standard deviation of states"},{"location":"markov/Three States Model/Three States Model/#plot-equilibrium","text":"The plot represents how fraction of states fluctuate through time 0 to T. The plot shows clear equilibrium as there in no significant change in the values. As we increase the total population of ion channels (N). The error minimizes. Theoretically for N = infinity, the expectation value converges to the analytical value. # plot results plt . figure(figsize = [ 10 , 4 ]) plt . plot(X,DF[ 'O' ],color = \"orange\" ,linewidth = 2 ,label = 'open' ) plt . plot(X,DF[ 'C' ],color = \"magenta\" , linewidth = 2 ,label = 'closed' ) plt . plot(X,DF[ 'I' ],color = \"blue\" ,linewidth = 2 ,label = 'inactive' ) plt . grid( True ) plt . xlabel( 'Time(t)' ,fontsize = 15 ) plt . ylabel( 'Fraction of states: y(t)' ,fontsize = 15 ) plt . title( \"Plot of fraction of states out of N states\" ,fontsize = 15 ) plt . legend() plt . savefig( \"Sim.png\" ) plt . show() I = 0.4 C = 0.36 O = 0.24","title":"Plot: Equilibrium"},{"location":"ncx/NCX Model/NCX Model/","text":"NCX Simulation Model import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns . set() % matplotlib inline import random as random import pandas as pd Parameters K_EN1_ENO = 0.33 K_ENO_EN1 = 0.33 K_ENO_EN2 = 0.33 K_EN2_ENO = 0.33 K_EC1_ECO = 0.33 K_ECO_EC1 = 0.33 K_ECO_EC2 = 0.33 K_EC2_ECO = 0.33 Weighted Probability Vector M = { \"EN1\" : [ 1 - K_EN1_ENO,K_EN1_ENO, 0 , 0 , 0 , 0 ], \"ENO\" : [K_ENO_EN1, 1 - K_ENO_EN1 - K_ENO_EN2,K_ENO_EN2, 0 , 0 , 0 ], \"EN2\" : [ 0 , K_EN2_ENO, 1 - K_EN2_ENO, 0 , 0 , 0 ], \"EC1\" : [ 0 , 0 , 0 , 1 - K_EC1_ECO,K_EC1_ECO, 0 ], \"ECO\" : [ 0 , 0 , 0 ,K_ECO_EC1, 1 - K_ECO_EC1 - K_ECO_EC2,K_ECO_EC2], \"EC2\" : [ 0 , 0 , 0 , 0 ,K_EC2_ECO, 1 - K_EC2_ECO]} M {'EN1': [0.6699999999999999, 0.33, 0, 0, 0, 0], 'ENO': [0.33, 0.3399999999999999, 0.33, 0, 0, 0], 'EN2': [0, 0.33, 0.6699999999999999, 0, 0, 0], 'EC1': [0, 0, 0, 0.6699999999999999, 0.33, 0], 'ECO': [0, 0, 0, 0.33, 0.3399999999999999, 0.33], 'EC2': [0, 0, 0, 0, 0.33, 0.6699999999999999]} class Channel ( object ): '''This class represents a ncx channel''' def __init__ ( self ,state,x,y): self . x = x self . y = y self . states = [ \"EN1\" , \"ENO\" , \"EN2\" , \"EC1\" , \"ECO\" , \"EC2\" ] self . state = state def update ( self ,M): '''Update the state based on markov model''' new_state = np . random . choice( self . states, p = M[ self . state]) self . state = new_state def flip ( self ): if self . state in [ \"EN1\" , \"EC1\" ]: self . state = random . choice([ \"EN1\" , \"EC1\" ]) elif self . state in [ \"EN2\" , \"EC2\" ]: self . state = random . choice([ \"EN2\" , \"EC2\" ]) class System ( object ): '''This class represents a 2D lattice system of NCX channels''' def __init__ ( self ,Channel,M): '''lattice dimension''' self . Lx = 20 self . Ly = 20 '''Markov transition matrix''' self . M = M '''A single channel object''' self . Channel = Channel '''concentration of ions''' self . nNa_out = 1000 self . nCa_out = 1000 self . nNa_in = 1000 self . nCa_in = 1000 self . nNa_o = 0 self . nCa_o = 0 '''concentration of channels''' self . nEN1 = 0 self . nENO = 0 self . nEN2 = 0 self . nEC1 = 0 self . nECO = 0 self . nEC2 = 0 '''Initiation channel 2D system''' self . U = [[ \"o\" for i in range ( self . Lx)] for j in range ( self . Ly)] self . DATA = [] def start ( self ): for i in range ( self . Lx): for j in range ( self . Ly): r_state = random . choice([ \"EC1\" , \"EN1\" ]) self . U[i][j] = self . Channel(r_state,i,j) if r_state == \"EN1\" : self . nEN1 += 1 if r_state == \"ENO\" : self . nENO += 1 self . nNa_o += 3 if r_state == \"EN2\" : self . nEN2 += 1 if r_state == \"EC1\" : self . nEC1 += 1 if r_state == \"ECO\" : self . nECO += 1 self . nCa_o += 1 if r_state == \"EC2\" : self . nEC2 += 1 def run ( self , verbose = False ): for i in range ( self . Lx): for j in range ( self . Ly): new_state = None old_state = None channel = self . U[i][j] old_state = channel . state '''generate the next markov state''' channel . update( self . M) new_state = channel . state if new_state != old_state: if verbose: print ( \"updated from\" , old_state, \" to \" , new_state,\\ \" at \" , channel . x, channel . y) '''update the ion concentration''' if new_state == \"EN1\" and old_state == \"ENO\" : self . nNa_in += 1 self . nNa_o -= 1 self . nEN1 += 1 self . nENO -= 1 elif new_state == \"ENO\" and old_state == \"EN1\" : self . nENO += 1 self . nEN1 -= 1 self . nNa_o += 1 self . nNa_in -= 1 elif new_state == \"ENO\" and old_state == \"EN2\" : self . nENO += 1 self . nEN2 -= 1 self . nNa_o += 1 self . nNa_out -= 1 elif new_state == \"EN2\" and old_state == \"ENO\" : self . nNa_out += 1 self . nNa_o -= 1 self . nEN2 += 1 self . nENO -= 1 elif new_state == \"EC1\" and old_state == \"ECO\" : self . nCa_in += 1 self . nCa_o -= 1 self . nEC1 += 1 self . nECO -= 1 elif new_state == \"ECO\" and old_state == \"EC1\" : self . nECO += 1 self . nEC1 -= 1 self . nCa_o += 1 self . nCa_in -= 1 elif new_state == \"ECO\" and old_state == \"EC2\" : self . nECO += 1 self . nEC2 -= 1 self . nCa_o += 1 self . nCa_out -= 1 elif new_state == \"EC2\" and old_state == \"ECO\" : self . nCa_out += 1 self . nCa_o -= 1 self . nEC2 += 1 self . nECO -= 1 else : if verbose: print ( \"not updated\" , \" old is \" , old_state,\\ \" new is \" ,new_state,\\ \"at\" , channel . x, channel . y) if channel . state in [ \"EN1\" , \"EN2\" , \"EC1\" , \"EC2\" ]: channel . flip() fliped_state = channel . state if verbose: print ( \"Flipped from \" , new_state, \" to \" , fliped_state) if new_state == \"EN1\" : if fliped_state == \"EC1\" : self . nEN1 -= 1 self . nEC1 += 1 elif new_state == \"EN2\" : if fliped_state == \"EC2\" : self . nEN2 -= 1 self . nEC2 += 1 elif new_state == \"EC1\" : if fliped_state == \"EN1\" : self . nEC1 -= 1 self . nEN1 += 1 elif new_state == \"EC2\" : if fliped_state == \"EN2\" : self . nEC2 -= 1 self . nEN2 += 1 self . U[i][j] = channel def simulate ( self ,T): self . DATA = [] for t in range (T): self . run() self . DATA . append({ \"time\" : t,\\ \"EN1\" : self . nEN1,\\ \"ENO\" : self . nENO,\\ \"EN2\" : self . nEN2,\\ \"EC1\" : self . nEC1,\\ \"EC2\" : self . nEC2,\\ \"ECO\" : self . nECO,\\ \"Na_out\" : self . nNa_out,\\ \"Na_in\" : self . nNa_in,\\ \"Na_occ\" : self . nNa_o,\\ \"CA_occ\" : self . nCa_o,\\ \"Ca_in\" : self . nCa_in,\\ \"Ca_out\" : self . nCa_out}) Simulation S = System(Channel,M) S . start() S . simulate(T = 100 ) DataFrame DF = pd . DataFrame(S . DATA) DF . head( 5 ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } CA_occ Ca_in Ca_out EC1 EC2 ECO EN1 EN2 ENO Na_in Na_occ Na_out time 0 76 924 1000 120 0 76 140 0 64 936 64 1000 0 1 66 909 1025 130 25 66 96 21 62 917 62 1021 1 2 76 880 1044 86 42 76 106 35 55 912 55 1033 2 3 60 880 1060 90 40 60 91 62 57 901 57 1042 3 4 48 884 1068 93 51 48 84 58 66 893 66 1041 4 Results DF . plot(x = \"time\" , y = [ \"Ca_in\" , \"Ca_out\" , \"Na_in\" , \"Na_out\" ],figsize = [ 15 , 8 ]) &lt;matplotlib.axes._subplots.AxesSubplot at 0x10b259f60&gt; DF . plot(x = \"time\" , y = [ \"EN1\" , \"ENO\" , \"EN2\" , \"EC1\" , \"ECO\" , \"EC2\" ],figsize = [ 15 , 8 ]) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a1da2dba8&gt; DF . plot(x = \"time\" , y = [ \"EN1\" , \"ENO\" , \"EN2\" ],figsize = [ 15 , 8 ]) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a1dd50390&gt; DF . plot(x = \"time\" , y = [ \"EC1\" , \"ECO\" , \"EC2\" ],figsize = [ 15 , 8 ]) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a1d9a76d8&gt; Markov Chain C = Channel( \"EN1\" , 2 , 2 ) print (C . state) for i in range ( 10 ): C . update(M) print (C . state) C . flip() print (C . state) EN1 ENO ENO ENO ENO ENO ENO EN1 EC1 EC1 EN1 ENO ENO EN2 EC2 ECO ECO EC2 EN2 EN2 EC2","title":"Simulation"},{"location":"ncx/NCX Model/NCX Model/#ncx-simulation-model","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns . set() % matplotlib inline import random as random import pandas as pd","title":"NCX Simulation Model"},{"location":"ncx/NCX Model/NCX Model/#parameters","text":"K_EN1_ENO = 0.33 K_ENO_EN1 = 0.33 K_ENO_EN2 = 0.33 K_EN2_ENO = 0.33 K_EC1_ECO = 0.33 K_ECO_EC1 = 0.33 K_ECO_EC2 = 0.33 K_EC2_ECO = 0.33","title":"Parameters"},{"location":"ncx/NCX Model/NCX Model/#weighted-probability-vector","text":"M = { \"EN1\" : [ 1 - K_EN1_ENO,K_EN1_ENO, 0 , 0 , 0 , 0 ], \"ENO\" : [K_ENO_EN1, 1 - K_ENO_EN1 - K_ENO_EN2,K_ENO_EN2, 0 , 0 , 0 ], \"EN2\" : [ 0 , K_EN2_ENO, 1 - K_EN2_ENO, 0 , 0 , 0 ], \"EC1\" : [ 0 , 0 , 0 , 1 - K_EC1_ECO,K_EC1_ECO, 0 ], \"ECO\" : [ 0 , 0 , 0 ,K_ECO_EC1, 1 - K_ECO_EC1 - K_ECO_EC2,K_ECO_EC2], \"EC2\" : [ 0 , 0 , 0 , 0 ,K_EC2_ECO, 1 - K_EC2_ECO]} M {'EN1': [0.6699999999999999, 0.33, 0, 0, 0, 0], 'ENO': [0.33, 0.3399999999999999, 0.33, 0, 0, 0], 'EN2': [0, 0.33, 0.6699999999999999, 0, 0, 0], 'EC1': [0, 0, 0, 0.6699999999999999, 0.33, 0], 'ECO': [0, 0, 0, 0.33, 0.3399999999999999, 0.33], 'EC2': [0, 0, 0, 0, 0.33, 0.6699999999999999]} class Channel ( object ): '''This class represents a ncx channel''' def __init__ ( self ,state,x,y): self . x = x self . y = y self . states = [ \"EN1\" , \"ENO\" , \"EN2\" , \"EC1\" , \"ECO\" , \"EC2\" ] self . state = state def update ( self ,M): '''Update the state based on markov model''' new_state = np . random . choice( self . states, p = M[ self . state]) self . state = new_state def flip ( self ): if self . state in [ \"EN1\" , \"EC1\" ]: self . state = random . choice([ \"EN1\" , \"EC1\" ]) elif self . state in [ \"EN2\" , \"EC2\" ]: self . state = random . choice([ \"EN2\" , \"EC2\" ]) class System ( object ): '''This class represents a 2D lattice system of NCX channels''' def __init__ ( self ,Channel,M): '''lattice dimension''' self . Lx = 20 self . Ly = 20 '''Markov transition matrix''' self . M = M '''A single channel object''' self . Channel = Channel '''concentration of ions''' self . nNa_out = 1000 self . nCa_out = 1000 self . nNa_in = 1000 self . nCa_in = 1000 self . nNa_o = 0 self . nCa_o = 0 '''concentration of channels''' self . nEN1 = 0 self . nENO = 0 self . nEN2 = 0 self . nEC1 = 0 self . nECO = 0 self . nEC2 = 0 '''Initiation channel 2D system''' self . U = [[ \"o\" for i in range ( self . Lx)] for j in range ( self . Ly)] self . DATA = [] def start ( self ): for i in range ( self . Lx): for j in range ( self . Ly): r_state = random . choice([ \"EC1\" , \"EN1\" ]) self . U[i][j] = self . Channel(r_state,i,j) if r_state == \"EN1\" : self . nEN1 += 1 if r_state == \"ENO\" : self . nENO += 1 self . nNa_o += 3 if r_state == \"EN2\" : self . nEN2 += 1 if r_state == \"EC1\" : self . nEC1 += 1 if r_state == \"ECO\" : self . nECO += 1 self . nCa_o += 1 if r_state == \"EC2\" : self . nEC2 += 1 def run ( self , verbose = False ): for i in range ( self . Lx): for j in range ( self . Ly): new_state = None old_state = None channel = self . U[i][j] old_state = channel . state '''generate the next markov state''' channel . update( self . M) new_state = channel . state if new_state != old_state: if verbose: print ( \"updated from\" , old_state, \" to \" , new_state,\\ \" at \" , channel . x, channel . y) '''update the ion concentration''' if new_state == \"EN1\" and old_state == \"ENO\" : self . nNa_in += 1 self . nNa_o -= 1 self . nEN1 += 1 self . nENO -= 1 elif new_state == \"ENO\" and old_state == \"EN1\" : self . nENO += 1 self . nEN1 -= 1 self . nNa_o += 1 self . nNa_in -= 1 elif new_state == \"ENO\" and old_state == \"EN2\" : self . nENO += 1 self . nEN2 -= 1 self . nNa_o += 1 self . nNa_out -= 1 elif new_state == \"EN2\" and old_state == \"ENO\" : self . nNa_out += 1 self . nNa_o -= 1 self . nEN2 += 1 self . nENO -= 1 elif new_state == \"EC1\" and old_state == \"ECO\" : self . nCa_in += 1 self . nCa_o -= 1 self . nEC1 += 1 self . nECO -= 1 elif new_state == \"ECO\" and old_state == \"EC1\" : self . nECO += 1 self . nEC1 -= 1 self . nCa_o += 1 self . nCa_in -= 1 elif new_state == \"ECO\" and old_state == \"EC2\" : self . nECO += 1 self . nEC2 -= 1 self . nCa_o += 1 self . nCa_out -= 1 elif new_state == \"EC2\" and old_state == \"ECO\" : self . nCa_out += 1 self . nCa_o -= 1 self . nEC2 += 1 self . nECO -= 1 else : if verbose: print ( \"not updated\" , \" old is \" , old_state,\\ \" new is \" ,new_state,\\ \"at\" , channel . x, channel . y) if channel . state in [ \"EN1\" , \"EN2\" , \"EC1\" , \"EC2\" ]: channel . flip() fliped_state = channel . state if verbose: print ( \"Flipped from \" , new_state, \" to \" , fliped_state) if new_state == \"EN1\" : if fliped_state == \"EC1\" : self . nEN1 -= 1 self . nEC1 += 1 elif new_state == \"EN2\" : if fliped_state == \"EC2\" : self . nEN2 -= 1 self . nEC2 += 1 elif new_state == \"EC1\" : if fliped_state == \"EN1\" : self . nEC1 -= 1 self . nEN1 += 1 elif new_state == \"EC2\" : if fliped_state == \"EN2\" : self . nEC2 -= 1 self . nEN2 += 1 self . U[i][j] = channel def simulate ( self ,T): self . DATA = [] for t in range (T): self . run() self . DATA . append({ \"time\" : t,\\ \"EN1\" : self . nEN1,\\ \"ENO\" : self . nENO,\\ \"EN2\" : self . nEN2,\\ \"EC1\" : self . nEC1,\\ \"EC2\" : self . nEC2,\\ \"ECO\" : self . nECO,\\ \"Na_out\" : self . nNa_out,\\ \"Na_in\" : self . nNa_in,\\ \"Na_occ\" : self . nNa_o,\\ \"CA_occ\" : self . nCa_o,\\ \"Ca_in\" : self . nCa_in,\\ \"Ca_out\" : self . nCa_out})","title":"Weighted Probability Vector"},{"location":"ncx/NCX Model/NCX Model/#simulation","text":"S = System(Channel,M) S . start() S . simulate(T = 100 )","title":"Simulation"},{"location":"ncx/NCX Model/NCX Model/#dataframe","text":"DF = pd . DataFrame(S . DATA) DF . head( 5 ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } CA_occ Ca_in Ca_out EC1 EC2 ECO EN1 EN2 ENO Na_in Na_occ Na_out time 0 76 924 1000 120 0 76 140 0 64 936 64 1000 0 1 66 909 1025 130 25 66 96 21 62 917 62 1021 1 2 76 880 1044 86 42 76 106 35 55 912 55 1033 2 3 60 880 1060 90 40 60 91 62 57 901 57 1042 3 4 48 884 1068 93 51 48 84 58 66 893 66 1041 4","title":"DataFrame"},{"location":"ncx/NCX Model/NCX Model/#results","text":"DF . plot(x = \"time\" , y = [ \"Ca_in\" , \"Ca_out\" , \"Na_in\" , \"Na_out\" ],figsize = [ 15 , 8 ]) &lt;matplotlib.axes._subplots.AxesSubplot at 0x10b259f60&gt; DF . plot(x = \"time\" , y = [ \"EN1\" , \"ENO\" , \"EN2\" , \"EC1\" , \"ECO\" , \"EC2\" ],figsize = [ 15 , 8 ]) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a1da2dba8&gt; DF . plot(x = \"time\" , y = [ \"EN1\" , \"ENO\" , \"EN2\" ],figsize = [ 15 , 8 ]) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a1dd50390&gt; DF . plot(x = \"time\" , y = [ \"EC1\" , \"ECO\" , \"EC2\" ],figsize = [ 15 , 8 ]) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a1d9a76d8&gt;","title":"Results"},{"location":"ncx/NCX Model/NCX Model/#markov-chain","text":"C = Channel( \"EN1\" , 2 , 2 ) print (C . state) for i in range ( 10 ): C . update(M) print (C . state) C . flip() print (C . state) EN1 ENO ENO ENO ENO ENO ENO EN1 EC1 EC1 EN1 ENO ENO EN2 EC2 ECO ECO EC2 EN2 EN2 EC2","title":"Markov Chain"},{"location":"ode/Five-States-Model/Five-States-Model/","text":"Eigen Value Method import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt import seaborn as sns sns . set() Five State Markov Model $${\\frac{dO(t)}{dt} = k_{io}I(t) + k_{co}C(t) - (k_{oi} + k_{oc})O(t)}$$ $${\\frac{dC(t)}{dt} = k_{oc}O(t) + k_{ic}I(t) + k_{pc}P(t) - (k_{co} + k_{ci} + k_{cp})C(t)}$$ $${\\frac{dI(t)}{dt} = k_{oi}O(t) + k_{ci}C(t) - (k_{io} + k_{ic})I(t)}$$ $${\\frac{dP(t)}{dt} = k_{cp}C(t) + k_{qp}Q(t) - (k_{pc} + k_{pq})P(t)}$$ $${\\frac{dQ(t)}{dt} = k_{pq}P(t) - k_{qp}Q(t)}$$ Using $${Q = 1 - I - C - O - P}$$ for equilibrium $${k_{io}I(t) + k_{co}C(t) - (k_{oi} + k_{oc})O(t) = 0}$$ $${k_{oc}O(t) + k_{ic}I(t) + k_{pc}P(t) - (k_{co} + k_{ci} + k_{cp})C(t) = 0}$$ $${k_{oi}O(t) + k_{ci}C(t) - (k_{io} + k_{ic})I(t) = 0}$$ $${ (k_{qp} - k_{cp})C(t) + (k_{pc} + k_{pq} + k_{qp})P(t) + k_{qp}I(t) + k_{qp}O(t) = k_{qp}}$$ Algeraic Solution $$\\left( \\begin{array}{cccc} -(k_{oi} + k_{oc}) & k_{co} & k_{io} & 0\\cr k_{oc} & - (k_{co} + k_{ci} + k_{cp}) & k_{ic} & k_{pc}\\cr k_{oi} & k_{ci} & - (k_{io} + k_{ic}) & 0\\cr k_{qp} & (k_{qp} - k_{cp}) & k_{qp} & (k_{pc} + k_{pq} + k_{qp})\\cr \\end{array} \\right) \\left( \\begin{array}{c} O\\cr C\\cr I\\cr P\\cr \\end{array} \\right) = \\left( \\begin{array}{c} 0\\cr 0\\cr 0\\cr k_{qp}\\cr \\end{array} \\right) $$ k = { \"koi\" : 0.32 ,\\ \"kio\" : 0.24 ,\\ \"kco\" : 0.31 ,\\ \"koc\" : 0.12 ,\\ \"kic\" : 0.34 ,\\ \"kci\" : 0.23 ,\\ \"kcp\" : 0.37 ,\\ \"kpc\" : 0.22 ,\\ \"kpq\" : 0.31 ,\\ \"kqp\" : 0.15 } A = np . array([[ - (k[ 'koi' ] + k[ 'koc' ]), k[ 'kco' ], k[ 'kio' ], 0 ], [k[ 'koc' ], - (k[ 'kco' ] + k[ 'kci' ] + k[ 'kcp' ]), k[ 'kic' ],k[ 'kpc' ]], [k[ 'koi' ], k[ 'kci' ], - (k[ 'kio' ] + k[ 'kic' ]), 0 ], [k[ 'kqp' ], (k[ 'kqp' ] - k[ 'kcp' ]), k[ 'kqp' ],(k[ 'kpc' ] + k[ 'kpq' ] + k[ 'kqp' ])]]) A array([[-0.44, 0.31, 0.24, 0. ], [ 0.12, -0.91, 0.34, 0.22], [ 0.32, 0.23, -0.58, 0. ], [ 0.15, -0.22, 0.15, 0.68]]) b = np . array([ 0 , 0 , 0 ,k[ 'kqp' ]]) from numpy import linalg x = np . linalg . solve(A, b) x array([0.1532031 , 0.11630397, 0.13064639, 0.19560213]) 1 - sum (x) 0.4042444074447815 Numerical Solution $${\\frac{dO(t)}{dt} = k_{io}I(t) + k_{co}C(t) - (k_{oi} + k_{oc})O(t)}$$ $${\\frac{dC(t)}{dt} = k_{oc}O(t) + k_{ic}I(t) + k_{pc}P(t) - (k_{co} + k_{ci} + k_{cp})C(t)}$$ $${\\frac{dI(t)}{dt} = k_{oi}O(t) + k_{ci}C(t) - (k_{io} + k_{ic})I(t)}$$ $${\\frac{dP(t)}{dt} = k_{cp}C(t) + k_{qp}Q(t) - (k_{pc} + k_{pq})P(t)}$$ $${Q = 1 - I - C - O - P}$$ # function that returns dy/dt def model (y,t,k): '''y[0] = O, y[1] = C, y[2] = I, y[3] = P ''' dy1dt = - (k[ 'koi' ] + k[ 'koc' ]) * y[ 0 ] + k[ 'kco' ] * y[ 1 ] + k[ 'kio' ] * y[ 2 ] dy2dt = k[ 'koc' ] * y[ 0 ] - (k[ 'kco' ] + k[ 'kci' ] + k[ 'kcp' ]) * y[ 1 ] \\ + k[ 'kic' ] * y[ 2 ] + k[ 'kpc' ] * y[ 3 ] dy3dt = k[ 'koi' ] * y[ 0 ] + k[ 'kci' ] * y[ 1 ] - (k[ 'kio' ] + k[ 'kic' ]) * y[ 2 ] dy4dt = k[ 'kqp' ] - k[ 'kqp' ] * y[ 0 ] - (k[ 'kqp' ] - k[ 'kcp' ]) * y[ 1 ] \\ - k[ 'kqp' ] * y[ 2 ] - (k[ 'kqp' ] + k[ 'kpc' ] + k[ 'kpq' ]) * y[ 3 ] dydt = [dy1dt,dy2dt,dy3dt,dy4dt] return dydt N = 1 T = 45 # initial condition y0 = [ 0 , 0 , 0 , 1 ] # time points t = np . linspace( 0 ,T) '''solve ODEs''' y = odeint(model,y0,t,args = (k,)) y1 = np . empty_like(t) y2 = np . empty_like(t) y3 = np . empty_like(t) y4 = np . empty_like(t) y5 = np . empty_like(t) for i in range ( len (t)): y1[i] = y[i][ 0 ] y2[i] = y[i][ 1 ] y3[i] = y[i][ 2 ] y4[i] = y[i][ 3 ] y5[i] = 1 - y1[i] - y2[i] - y3[i] - y4[i] y1[T],y2[T],y3[T],y4[T],y5[T] (0.15207871024029435, 0.11582562983472518, 0.12966873235864482, 0.19596397516696185, 0.4064629523993738) # plot results plt . figure(figsize = [ 12 , 5 ]) plt . plot(t,y1,linewidth = 2 ,label = 'open' ) plt . plot(t,y2,linewidth = 2 ,label = 'closed' ) plt . plot(t,y3,linewidth = 2 ,label = 'inactive' ) plt . plot(t,y4,linewidth = 2 ,label = 'P' ) plt . plot(t,y5,linewidth = 2 ,label = 'Q' ) plt . xlabel( 'time' ) plt . ylabel( 'y(t)' ) plt . legend() plt . show()","title":"Five States Model"},{"location":"ode/Five-States-Model/Five-States-Model/#eigen-value-method","text":"import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt import seaborn as sns sns . set()","title":"Eigen Value Method"},{"location":"ode/Five-States-Model/Five-States-Model/#five-state-markov-model","text":"$${\\frac{dO(t)}{dt} = k_{io}I(t) + k_{co}C(t) - (k_{oi} + k_{oc})O(t)}$$ $${\\frac{dC(t)}{dt} = k_{oc}O(t) + k_{ic}I(t) + k_{pc}P(t) - (k_{co} + k_{ci} + k_{cp})C(t)}$$ $${\\frac{dI(t)}{dt} = k_{oi}O(t) + k_{ci}C(t) - (k_{io} + k_{ic})I(t)}$$ $${\\frac{dP(t)}{dt} = k_{cp}C(t) + k_{qp}Q(t) - (k_{pc} + k_{pq})P(t)}$$ $${\\frac{dQ(t)}{dt} = k_{pq}P(t) - k_{qp}Q(t)}$$ Using $${Q = 1 - I - C - O - P}$$ for equilibrium $${k_{io}I(t) + k_{co}C(t) - (k_{oi} + k_{oc})O(t) = 0}$$ $${k_{oc}O(t) + k_{ic}I(t) + k_{pc}P(t) - (k_{co} + k_{ci} + k_{cp})C(t) = 0}$$ $${k_{oi}O(t) + k_{ci}C(t) - (k_{io} + k_{ic})I(t) = 0}$$ $${ (k_{qp} - k_{cp})C(t) + (k_{pc} + k_{pq} + k_{qp})P(t) + k_{qp}I(t) + k_{qp}O(t) = k_{qp}}$$","title":"Five State Markov Model"},{"location":"ode/Five-States-Model/Five-States-Model/#algeraic-solution","text":"$$\\left( \\begin{array}{cccc} -(k_{oi} + k_{oc}) & k_{co} & k_{io} & 0\\cr k_{oc} & - (k_{co} + k_{ci} + k_{cp}) & k_{ic} & k_{pc}\\cr k_{oi} & k_{ci} & - (k_{io} + k_{ic}) & 0\\cr k_{qp} & (k_{qp} - k_{cp}) & k_{qp} & (k_{pc} + k_{pq} + k_{qp})\\cr \\end{array} \\right) \\left( \\begin{array}{c} O\\cr C\\cr I\\cr P\\cr \\end{array} \\right) = \\left( \\begin{array}{c} 0\\cr 0\\cr 0\\cr k_{qp}\\cr \\end{array} \\right) $$ k = { \"koi\" : 0.32 ,\\ \"kio\" : 0.24 ,\\ \"kco\" : 0.31 ,\\ \"koc\" : 0.12 ,\\ \"kic\" : 0.34 ,\\ \"kci\" : 0.23 ,\\ \"kcp\" : 0.37 ,\\ \"kpc\" : 0.22 ,\\ \"kpq\" : 0.31 ,\\ \"kqp\" : 0.15 } A = np . array([[ - (k[ 'koi' ] + k[ 'koc' ]), k[ 'kco' ], k[ 'kio' ], 0 ], [k[ 'koc' ], - (k[ 'kco' ] + k[ 'kci' ] + k[ 'kcp' ]), k[ 'kic' ],k[ 'kpc' ]], [k[ 'koi' ], k[ 'kci' ], - (k[ 'kio' ] + k[ 'kic' ]), 0 ], [k[ 'kqp' ], (k[ 'kqp' ] - k[ 'kcp' ]), k[ 'kqp' ],(k[ 'kpc' ] + k[ 'kpq' ] + k[ 'kqp' ])]]) A array([[-0.44, 0.31, 0.24, 0. ], [ 0.12, -0.91, 0.34, 0.22], [ 0.32, 0.23, -0.58, 0. ], [ 0.15, -0.22, 0.15, 0.68]]) b = np . array([ 0 , 0 , 0 ,k[ 'kqp' ]]) from numpy import linalg x = np . linalg . solve(A, b) x array([0.1532031 , 0.11630397, 0.13064639, 0.19560213]) 1 - sum (x) 0.4042444074447815","title":"Algeraic Solution"},{"location":"ode/Five-States-Model/Five-States-Model/#numerical-solution","text":"$${\\frac{dO(t)}{dt} = k_{io}I(t) + k_{co}C(t) - (k_{oi} + k_{oc})O(t)}$$ $${\\frac{dC(t)}{dt} = k_{oc}O(t) + k_{ic}I(t) + k_{pc}P(t) - (k_{co} + k_{ci} + k_{cp})C(t)}$$ $${\\frac{dI(t)}{dt} = k_{oi}O(t) + k_{ci}C(t) - (k_{io} + k_{ic})I(t)}$$ $${\\frac{dP(t)}{dt} = k_{cp}C(t) + k_{qp}Q(t) - (k_{pc} + k_{pq})P(t)}$$ $${Q = 1 - I - C - O - P}$$ # function that returns dy/dt def model (y,t,k): '''y[0] = O, y[1] = C, y[2] = I, y[3] = P ''' dy1dt = - (k[ 'koi' ] + k[ 'koc' ]) * y[ 0 ] + k[ 'kco' ] * y[ 1 ] + k[ 'kio' ] * y[ 2 ] dy2dt = k[ 'koc' ] * y[ 0 ] - (k[ 'kco' ] + k[ 'kci' ] + k[ 'kcp' ]) * y[ 1 ] \\ + k[ 'kic' ] * y[ 2 ] + k[ 'kpc' ] * y[ 3 ] dy3dt = k[ 'koi' ] * y[ 0 ] + k[ 'kci' ] * y[ 1 ] - (k[ 'kio' ] + k[ 'kic' ]) * y[ 2 ] dy4dt = k[ 'kqp' ] - k[ 'kqp' ] * y[ 0 ] - (k[ 'kqp' ] - k[ 'kcp' ]) * y[ 1 ] \\ - k[ 'kqp' ] * y[ 2 ] - (k[ 'kqp' ] + k[ 'kpc' ] + k[ 'kpq' ]) * y[ 3 ] dydt = [dy1dt,dy2dt,dy3dt,dy4dt] return dydt N = 1 T = 45 # initial condition y0 = [ 0 , 0 , 0 , 1 ] # time points t = np . linspace( 0 ,T) '''solve ODEs''' y = odeint(model,y0,t,args = (k,)) y1 = np . empty_like(t) y2 = np . empty_like(t) y3 = np . empty_like(t) y4 = np . empty_like(t) y5 = np . empty_like(t) for i in range ( len (t)): y1[i] = y[i][ 0 ] y2[i] = y[i][ 1 ] y3[i] = y[i][ 2 ] y4[i] = y[i][ 3 ] y5[i] = 1 - y1[i] - y2[i] - y3[i] - y4[i] y1[T],y2[T],y3[T],y4[T],y5[T] (0.15207871024029435, 0.11582562983472518, 0.12966873235864482, 0.19596397516696185, 0.4064629523993738) # plot results plt . figure(figsize = [ 12 , 5 ]) plt . plot(t,y1,linewidth = 2 ,label = 'open' ) plt . plot(t,y2,linewidth = 2 ,label = 'closed' ) plt . plot(t,y3,linewidth = 2 ,label = 'inactive' ) plt . plot(t,y4,linewidth = 2 ,label = 'P' ) plt . plot(t,y5,linewidth = 2 ,label = 'Q' ) plt . xlabel( 'time' ) plt . ylabel( 'y(t)' ) plt . legend() plt . show()","title":"Numerical Solution"},{"location":"ode/Introduction/Introduction/","text":"Ordinary Differential Equation import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt import seaborn as sns sns . set() Ordinary differential Equation Consider the differential equation: $$\\large{\\frac{dy(t)}{dt} = - ky(t)}$$ with $ k =0.3$ def model (y,t): k = 0.3 dydt = - k * y return dydt # initial condition y0 = 5 # time points t = np . linspace( 0 , 20 ) # solve ODE y = odeint(model,y0,t) for it, iy in zip (t[ 0 : 5 ],y[ 0 : 5 ]): print (it,iy) 0.0 [5.] 0.40816326530612246 [4.42375528] 0.8163265306122449 [3.91392204] 1.2244897959183674 [3.46284668] 1.6326530612244898 [3.06375722] # plot results plt . figure(figsize = [ 8 , 5 ]) plt . plot(t,y) plt . xlabel( 'time' ) plt . ylabel( 'y(t)' ) plt . show() Simultaneous differential equations $$\\large{\\frac{dy_1(t)}{dt} = - k_1y_1(t)}$$ $$\\large{\\frac{dy_2(t)}{dt} = k_2 \\sin(t)}$$ $$\\large{\\frac{dy_3(t)}{dt} = k_3 \\exp(-t)}$$ # function that returns dy/dt def model (y,t,k): dy1dt = - k[ 0 ] * y[ 0 ] dy2dt = k[ 1 ] * np . sin(t) dy3dt = k[ 2 ] * np . exp( - t) dydt = [dy1dt,dy2dt,dy3dt] return dydt # initial condition y0 = [ 5 , 0 , 0 ] # time points t = np . linspace( 0 , 20 ) # solve k1 = 0.1 k2 = 2.0 k3 = 3.0 k = [k1,k2,k3] '''solve ODEs''' y = odeint(model,y0,t,args = (k,)) y1 = np . empty_like(t) y2 = np . empty_like(t) y3 = np . empty_like(t) for i in range ( len (t)): y1[i] = y[i][ 0 ] y2[i] = y[i][ 1 ] y3[i] = y[i][ 2 ] # plot results plt . figure(figsize = [ 15 , 5 ]) plt . plot(t,y1, 'r-' ,linewidth = 2 ,label = 'y1' ) plt . plot(t,y2, 'b--' ,linewidth = 2 ,label = 'y2' ) plt . plot(t,y3, 'g:' ,linewidth = 2 ,label = 'y3' ) plt . xlabel( 'time' ) plt . ylabel( 'y(t)' ) plt . legend() plt . show() Implementing $tspan$ method $$\\large{2\\frac{dx(t)}{dt} = - x(t) + u(t)}$$ $$\\large{5 \\frac{dy(t)}{dt} = -y(t) + x(t)}$$ $$u = 2S(t-5),~~ x(0) = 0,~~ y(0) =0$$ # function that returns dz/dt def model (z,t,u): x = z[ 0 ] y = z[ 1 ] dxdt = ( - x + u) / 2.0 dydt = ( - y + x) / 5.0 dzdt = [dxdt,dydt] return dzdt # initial condition z0 = [ 0 , 0 ] # number of time points n = 401 # time points t = np . linspace( 0 , 40 ,n) # step input u = np . zeros(n) # change to 2.0 at time = 5.0 u[ 51 :] = 2.0 # store solution x = np . empty_like(t) y = np . empty_like(t) # record initial conditions x[ 0 ] = z0[ 0 ] y[ 0 ] = z0[ 1 ] # solve ODE for i in range ( 1 ,n): # span for next time step tspan = [t[i - 1 ],t[i]] # solve for next step z = odeint(model,z0,tspan,args = (u[i],)) # store solution for plotting x[i] = z[ 1 ][ 0 ] y[i] = z[ 1 ][ 1 ] # next initial condition z0 = z[ 1 ] # plot results plt . figure(figsize = [ 15 , 5 ]) plt . plot(t,u, 'g:' ,label = 'u(t)' ) plt . plot(t,x, 'b-' ,label = 'x(t)' ) plt . plot(t,y, 'r--' ,label = 'y(t)' ) plt . ylabel( 'values' ) plt . xlabel( 'time' ) plt . legend(loc = 'best' ) plt . show()","title":"Introduction"},{"location":"ode/Introduction/Introduction/#ordinary-differential-equation","text":"import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt import seaborn as sns sns . set()","title":"Ordinary Differential Equation"},{"location":"ode/Introduction/Introduction/#ordinary-differential-equation_1","text":"Consider the differential equation: $$\\large{\\frac{dy(t)}{dt} = - ky(t)}$$ with $ k =0.3$ def model (y,t): k = 0.3 dydt = - k * y return dydt # initial condition y0 = 5 # time points t = np . linspace( 0 , 20 ) # solve ODE y = odeint(model,y0,t) for it, iy in zip (t[ 0 : 5 ],y[ 0 : 5 ]): print (it,iy) 0.0 [5.] 0.40816326530612246 [4.42375528] 0.8163265306122449 [3.91392204] 1.2244897959183674 [3.46284668] 1.6326530612244898 [3.06375722] # plot results plt . figure(figsize = [ 8 , 5 ]) plt . plot(t,y) plt . xlabel( 'time' ) plt . ylabel( 'y(t)' ) plt . show()","title":"Ordinary differential Equation"},{"location":"ode/Introduction/Introduction/#simultaneous-differential-equations","text":"$$\\large{\\frac{dy_1(t)}{dt} = - k_1y_1(t)}$$ $$\\large{\\frac{dy_2(t)}{dt} = k_2 \\sin(t)}$$ $$\\large{\\frac{dy_3(t)}{dt} = k_3 \\exp(-t)}$$ # function that returns dy/dt def model (y,t,k): dy1dt = - k[ 0 ] * y[ 0 ] dy2dt = k[ 1 ] * np . sin(t) dy3dt = k[ 2 ] * np . exp( - t) dydt = [dy1dt,dy2dt,dy3dt] return dydt # initial condition y0 = [ 5 , 0 , 0 ] # time points t = np . linspace( 0 , 20 ) # solve k1 = 0.1 k2 = 2.0 k3 = 3.0 k = [k1,k2,k3] '''solve ODEs''' y = odeint(model,y0,t,args = (k,)) y1 = np . empty_like(t) y2 = np . empty_like(t) y3 = np . empty_like(t) for i in range ( len (t)): y1[i] = y[i][ 0 ] y2[i] = y[i][ 1 ] y3[i] = y[i][ 2 ] # plot results plt . figure(figsize = [ 15 , 5 ]) plt . plot(t,y1, 'r-' ,linewidth = 2 ,label = 'y1' ) plt . plot(t,y2, 'b--' ,linewidth = 2 ,label = 'y2' ) plt . plot(t,y3, 'g:' ,linewidth = 2 ,label = 'y3' ) plt . xlabel( 'time' ) plt . ylabel( 'y(t)' ) plt . legend() plt . show()","title":"Simultaneous differential equations"},{"location":"ode/Introduction/Introduction/#implementing-tspan-method","text":"$$\\large{2\\frac{dx(t)}{dt} = - x(t) + u(t)}$$ $$\\large{5 \\frac{dy(t)}{dt} = -y(t) + x(t)}$$ $$u = 2S(t-5),~~ x(0) = 0,~~ y(0) =0$$ # function that returns dz/dt def model (z,t,u): x = z[ 0 ] y = z[ 1 ] dxdt = ( - x + u) / 2.0 dydt = ( - y + x) / 5.0 dzdt = [dxdt,dydt] return dzdt # initial condition z0 = [ 0 , 0 ] # number of time points n = 401 # time points t = np . linspace( 0 , 40 ,n) # step input u = np . zeros(n) # change to 2.0 at time = 5.0 u[ 51 :] = 2.0 # store solution x = np . empty_like(t) y = np . empty_like(t) # record initial conditions x[ 0 ] = z0[ 0 ] y[ 0 ] = z0[ 1 ] # solve ODE for i in range ( 1 ,n): # span for next time step tspan = [t[i - 1 ],t[i]] # solve for next step z = odeint(model,z0,tspan,args = (u[i],)) # store solution for plotting x[i] = z[ 1 ][ 0 ] y[i] = z[ 1 ][ 1 ] # next initial condition z0 = z[ 1 ] # plot results plt . figure(figsize = [ 15 , 5 ]) plt . plot(t,u, 'g:' ,label = 'u(t)' ) plt . plot(t,x, 'b-' ,label = 'x(t)' ) plt . plot(t,y, 'r--' ,label = 'y(t)' ) plt . ylabel( 'values' ) plt . xlabel( 'time' ) plt . legend(loc = 'best' ) plt . show()","title":"Implementing  $tspan$ method"},{"location":"ode/Three-States-Model/Three-States-Model/","text":"Ordinary Differential Equation import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt import seaborn as sns sns . set() Three State Markov Model $$\\ {\\frac{dO(t)}{dt} = k_{io}I(t) + k_{co}.C(t) - (k_{oi} + k_{oc})O(t)}$$ $$\\ {\\frac{dC(t)}{dt} = k_{oc}C(t) + k_{ic}.I(t) - (k_{co} + k_{ci})C(t)}$$ $$\\ {\\frac{dI(t)}{dt} = k_{oi}O(t) + k_{ci}.C(t) - (k_{io} + k_{ic})I(t)}$$ k = { \"koi\" : 0.5 ,\\ \"kio\" : 0.3 ,\\ \"kco\" : 0.6 ,\\ \"koc\" : 0.9 ,\\ \"kic\" : 0.72 ,\\ \"kci\" : 0.8 } Disregarding Total probability and infinite population of state # function that returns dy/dt def model (y,t,k): '''y[0] = O, y[1] = C, y[2] = I''' dy1dt = k[ 'kio' ] * y[ 2 ] + k[ 'kco' ] * y[ 1 ] - (k[ 'koi' ] + k[ 'koc' ]) * y[ 0 ] dy2dt = k[ 'koc' ] * y[ 1 ] + k[ 'kic' ] * y[ 2 ] - (k[ 'kco' ] + k[ 'kci' ]) * y[ 1 ] dy3dt = k[ 'koi' ] * y[ 0 ] + k[ 'kci' ] * y[ 1 ] - (k[ 'kio' ] + k[ 'kic' ]) * y[ 2 ] dydt = [dy1dt,dy2dt,dy3dt] return dydt np . linspace( 0 , 20 , 20 ,endpoint = True ) array([ 0. , 1.05263158, 2.10526316, 3.15789474, 4.21052632, 5.26315789, 6.31578947, 7.36842105, 8.42105263, 9.47368421, 10.52631579, 11.57894737, 12.63157895, 13.68421053, 14.73684211, 15.78947368, 16.84210526, 17.89473684, 18.94736842, 20. ]) # initial condition y0 = [ 1 , 0 , 0 ] # time points t = np . linspace( 0 , 20 ) '''solve ODEs''' y = odeint(model,y0,t,args = (k,)) y1 = np . empty_like(t) y2 = np . empty_like(t) y3 = np . empty_like(t) for i in range ( len (t)): y1[i] = y[i][ 0 ] y2[i] = y[i][ 1 ] y3[i] = y[i][ 2 ] # plot results plt . figure(figsize = [ 15 , 5 ]) plt . plot(t,y1, 'r-' ,linewidth = 2 ,label = 'open' ) plt . plot(t,y2, 'b--' ,linewidth = 2 ,label = 'closed' ) plt . plot(t,y3, 'g:' ,linewidth = 2 ,label = 'inactive' ) plt . xlabel( 'time' ) plt . ylabel( 'y(t)' ) plt . legend() plt . show() Considering total probability = 1 These equations : $$\\ {\\frac{dO(t)}{dt} = k_{io}I(t) + k_{co}.C(t) - (k_{oi} + k_{oc})O(t)}$$ $$\\ {\\frac{dC(t)}{dt} = k_{oc}C(t) + k_{ic}.I(t) - (k_{co} + k_{ci})C(t)}$$ $$\\ {\\frac{dI(t)}{dt} = k_{oi}O(t) + k_{ci}.C(t) - (k_{io} + k_{ic})I(t)}$$ with condition: $$\\ {I = 1 - (O + C)}$$ becomes: $$\\ {\\frac{dO(t)}{dt} = k_{io} + (k_{co} - k_{io}).C(t) - (k_{oi} + k_{oc} +k_{io})O(t)}$$ $$\\ {\\frac{dC(t)}{dt} = k_{ic} + (k_{oc} - k_{ic}).O(t) - (k_{co} + k_{ci} + k_{ic})C(t)}$$ # function that returns dy/dt def model2 (y,t,k): '''y[0] = O, y[1] = C, y[2] = I''' dy1dt = k[ 'kio' ] + (k[ 'kco' ] - k[ 'kio' ]) * y[ 1 ] - (k[ 'koi' ] + k[ 'koc' ] + k[ 'kio' ]) * y[ 0 ] dy2dt = k[ 'kic' ] + (k[ 'koc' ] - k[ 'kic' ]) * y[ 0 ] - (k[ 'kco' ] + k[ 'kci' ] + k[ 'kic' ]) * y[ 1 ] dydt = [dy1dt,dy2dt] return dydt N = 1 T = 10 # initial condition y0 = [N, 0 ] # time points t = np . linspace( 0 ,T) '''solve ODEs''' y = odeint(model2,y0,t,args = (k,)) y1 = np . empty_like(t) y2 = np . empty_like(t) for i in range ( len (t)): y1[i] = y[i][ 0 ] y2[i] = y[i][ 1 ] y3[i] = N - y[i][ 0 ] - y[i][ 1 ] # plot results plt . figure(figsize = [ 10 , 4 ]) plt . plot(t,y1, 'o:' ,color = \"orange\" ,linewidth = 2 ,label = 'open' ) plt . plot(t,y2, 'o:' ,color = \"magenta\" , linewidth = 2 ,label = 'closed' ) plt . plot(t,y3, 'o:' ,color = \"blue\" ,linewidth = 2 ,label = 'inactive' ) plt . grid( True ) plt . xlabel( 'Time(t)' ,fontsize = 15 ) plt . ylabel( 'Fraction of states: y(t)' ,fontsize = 15 ) plt . title( \"Plot of the intermediate solution of the simultaneous diff Eqn\" ,fontsize = 15 ) plt . legend() plt . savefig( \"SDE.png\" ) plt . show()","title":"Three States Model"},{"location":"ode/Three-States-Model/Three-States-Model/#ordinary-differential-equation","text":"import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt import seaborn as sns sns . set()","title":"Ordinary Differential Equation"},{"location":"ode/Three-States-Model/Three-States-Model/#three-state-markov-model","text":"$$\\ {\\frac{dO(t)}{dt} = k_{io}I(t) + k_{co}.C(t) - (k_{oi} + k_{oc})O(t)}$$ $$\\ {\\frac{dC(t)}{dt} = k_{oc}C(t) + k_{ic}.I(t) - (k_{co} + k_{ci})C(t)}$$ $$\\ {\\frac{dI(t)}{dt} = k_{oi}O(t) + k_{ci}.C(t) - (k_{io} + k_{ic})I(t)}$$ k = { \"koi\" : 0.5 ,\\ \"kio\" : 0.3 ,\\ \"kco\" : 0.6 ,\\ \"koc\" : 0.9 ,\\ \"kic\" : 0.72 ,\\ \"kci\" : 0.8 }","title":"Three State Markov Model"},{"location":"ode/Three-States-Model/Three-States-Model/#disregarding-total-probability-and-infinite-population-of-state","text":"# function that returns dy/dt def model (y,t,k): '''y[0] = O, y[1] = C, y[2] = I''' dy1dt = k[ 'kio' ] * y[ 2 ] + k[ 'kco' ] * y[ 1 ] - (k[ 'koi' ] + k[ 'koc' ]) * y[ 0 ] dy2dt = k[ 'koc' ] * y[ 1 ] + k[ 'kic' ] * y[ 2 ] - (k[ 'kco' ] + k[ 'kci' ]) * y[ 1 ] dy3dt = k[ 'koi' ] * y[ 0 ] + k[ 'kci' ] * y[ 1 ] - (k[ 'kio' ] + k[ 'kic' ]) * y[ 2 ] dydt = [dy1dt,dy2dt,dy3dt] return dydt np . linspace( 0 , 20 , 20 ,endpoint = True ) array([ 0. , 1.05263158, 2.10526316, 3.15789474, 4.21052632, 5.26315789, 6.31578947, 7.36842105, 8.42105263, 9.47368421, 10.52631579, 11.57894737, 12.63157895, 13.68421053, 14.73684211, 15.78947368, 16.84210526, 17.89473684, 18.94736842, 20. ]) # initial condition y0 = [ 1 , 0 , 0 ] # time points t = np . linspace( 0 , 20 ) '''solve ODEs''' y = odeint(model,y0,t,args = (k,)) y1 = np . empty_like(t) y2 = np . empty_like(t) y3 = np . empty_like(t) for i in range ( len (t)): y1[i] = y[i][ 0 ] y2[i] = y[i][ 1 ] y3[i] = y[i][ 2 ] # plot results plt . figure(figsize = [ 15 , 5 ]) plt . plot(t,y1, 'r-' ,linewidth = 2 ,label = 'open' ) plt . plot(t,y2, 'b--' ,linewidth = 2 ,label = 'closed' ) plt . plot(t,y3, 'g:' ,linewidth = 2 ,label = 'inactive' ) plt . xlabel( 'time' ) plt . ylabel( 'y(t)' ) plt . legend() plt . show()","title":"Disregarding Total probability and infinite population of state"},{"location":"ode/Three-States-Model/Three-States-Model/#considering-total-probability-1","text":"These equations : $$\\ {\\frac{dO(t)}{dt} = k_{io}I(t) + k_{co}.C(t) - (k_{oi} + k_{oc})O(t)}$$ $$\\ {\\frac{dC(t)}{dt} = k_{oc}C(t) + k_{ic}.I(t) - (k_{co} + k_{ci})C(t)}$$ $$\\ {\\frac{dI(t)}{dt} = k_{oi}O(t) + k_{ci}.C(t) - (k_{io} + k_{ic})I(t)}$$ with condition: $$\\ {I = 1 - (O + C)}$$ becomes: $$\\ {\\frac{dO(t)}{dt} = k_{io} + (k_{co} - k_{io}).C(t) - (k_{oi} + k_{oc} +k_{io})O(t)}$$ $$\\ {\\frac{dC(t)}{dt} = k_{ic} + (k_{oc} - k_{ic}).O(t) - (k_{co} + k_{ci} + k_{ic})C(t)}$$ # function that returns dy/dt def model2 (y,t,k): '''y[0] = O, y[1] = C, y[2] = I''' dy1dt = k[ 'kio' ] + (k[ 'kco' ] - k[ 'kio' ]) * y[ 1 ] - (k[ 'koi' ] + k[ 'koc' ] + k[ 'kio' ]) * y[ 0 ] dy2dt = k[ 'kic' ] + (k[ 'koc' ] - k[ 'kic' ]) * y[ 0 ] - (k[ 'kco' ] + k[ 'kci' ] + k[ 'kic' ]) * y[ 1 ] dydt = [dy1dt,dy2dt] return dydt N = 1 T = 10 # initial condition y0 = [N, 0 ] # time points t = np . linspace( 0 ,T) '''solve ODEs''' y = odeint(model2,y0,t,args = (k,)) y1 = np . empty_like(t) y2 = np . empty_like(t) for i in range ( len (t)): y1[i] = y[i][ 0 ] y2[i] = y[i][ 1 ] y3[i] = N - y[i][ 0 ] - y[i][ 1 ] # plot results plt . figure(figsize = [ 10 , 4 ]) plt . plot(t,y1, 'o:' ,color = \"orange\" ,linewidth = 2 ,label = 'open' ) plt . plot(t,y2, 'o:' ,color = \"magenta\" , linewidth = 2 ,label = 'closed' ) plt . plot(t,y3, 'o:' ,color = \"blue\" ,linewidth = 2 ,label = 'inactive' ) plt . grid( True ) plt . xlabel( 'Time(t)' ,fontsize = 15 ) plt . ylabel( 'Fraction of states: y(t)' ,fontsize = 15 ) plt . title( \"Plot of the intermediate solution of the simultaneous diff Eqn\" ,fontsize = 15 ) plt . legend() plt . savefig( \"SDE.png\" ) plt . show()","title":"Considering total probability = 1"}]}